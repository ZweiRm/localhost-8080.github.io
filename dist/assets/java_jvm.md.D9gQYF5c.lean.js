import{_ as n,C as r,c as p,o as d,ag as i,j as s,a as l,G as e}from"./chunks/framework.DPDPlp3K.js";const o="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png",h="/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1_8.png",k="/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.jpg",A=JSON.parse('{"title":"Java 虚拟机","description":"","frontmatter":{"prev":{"text":"API-输入输出类库","link":"java/API-io"},"next":{"text":"参考文献或资料","link":"java/references"}},"headers":[],"relativePath":"java/jvm.md","filePath":"java/jvm.md"}'),g={name:"java/jvm.md"},E={class:"warning custom-block"};function y(u,t,c,b,C,x){const a=r("Badge");return d(),p("div",null,[t[45]||(t[45]=i("",4)),s("ul",null,[t[19]||(t[19]=i("",4)),s("li",null,[t[11]||(t[11]=i("",3)),s("ul",null,[t[9]||(t[9]=s("li",null,[s("p",null,[l("静态区"),s("br"),l(" 存储静态属性和静态方法"),s("br"),l(" 静态属性存储在此区后自动赋默认值")])],-1)),t[10]||(t[10]=s("li",null,[s("p",null,[l("静态常量池"),s("br"),l(" 存储类成员属性和成员方法信息")])],-1)),s("li",null,[s("p",null,[t[0]||(t[0]=l("运行时常量池")),t[1]||(t[1]=s("br",null,null,-1)),t[2]||(t[2]=l(" 存储计算机常量和被 ")),t[3]||(t[3]=s("code",null,"final",-1)),t[4]||(t[4]=l(" 修饰的常量副本 逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。")),e(a,{type:"error",text:"Java 7.0-"}),t[5]||(t[5]=s("br",null,null,-1)),t[6]||(t[6]=l(" 运行时常量池剩下的东西还在方法区（永久代）中，但字符串常量池被从方法区拿到了堆中。")),e(a,{type:"warning",text:"Java 7.0"}),t[7]||(t[7]=s("br",null,null,-1)),t[8]||(t[8]=l(" 移除了永久代而用元空间取代, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间。")),e(a,{text:"Java 8.0+"})])])])]),s("li",null,[s("p",null,[t[12]||(t[12]=l("直接内存")),t[13]||(t[13]=s("br",null,null,-1)),t[14]||(t[14]=l(" 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。")),t[15]||(t[15]=s("br",null,null,-1)),t[16]||(t[16]=l(" 可能导致 OutOfMemoryError.")),t[17]||(t[17]=s("br",null,null,-1)),t[18]||(t[18]=l(" JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。")),e(a,{text:"Java 1.4+"})])])]),t[46]||(t[46]=s("p",null,"其中堆内存、方法区与直接内存是所有线程共享的，而栈内存（虚拟机栈）、本地方法栈与程序计数器是每个线程独有的。",-1)),s("p",null,[t[20]||(t[20]=l("在Java 8 后，虚拟机对内存分配有了更新")),e(a,{text:"Java 8.0+"}),t[21]||(t[21]=l("：")),t[22]||(t[22]=s("br",null,null,-1)),t[23]||(t[23]=s("img",{src:h,alt:"内存模型 1.8"},null,-1)),t[24]||(t[24]=l(" 在 Java 8 之后，通过合并 HotSpot 与 JRockit 虚拟机，永久代被元空间代替，而元空间使用直接内存。")),t[25]||(t[25]=s("br",null,null,-1)),t[26]||(t[26]=l(" 使用命令来调节元空间大小："))]),t[47]||(t[47]=i("",19)),s("ol",null,[t[43]||(t[43]=i("",1)),s("li",null,[t[42]||(t[42]=s("p",null,[l("连接"),s("br"),l(" 连接步骤分为三步：")],-1)),s("ol",null,[t[40]||(t[40]=i("",1)),s("li",null,[t[37]||(t[37]=l("准备")),t[38]||(t[38]=s("br",null,null,-1)),t[39]||(t[39]=l(" 正式为类变量分配内存并设置变量的初始值。")),s("div",E,[t[36]||(t[36]=s("p",{class:"custom-block-title"},"注意",-1)),s("ol",null,[t[34]||(t[34]=s("li",null,[l("该时刻仅分配静态变量（类变量, Class Variables）空间"),s("br"),l(" 实例变量会在对象实例化时随着对象一起被分配在堆内存中。")],-1)),s("li",null,[t[27]||(t[27]=l("永久代中字符串常量池、静态变量等被移入堆内存")),e(a,{text:"Java 7.0+"}),t[28]||(t[28]=s("br",null,null,-1)),t[29]||(t[29]=l(" 但是在 Java 7 之前的版本，静态变量会被分配到方法区中的静态常量池，HotSpot 通过永久代来实现方法区。")),t[30]||(t[30]=s("br",null,null,-1)),t[31]||(t[31]=l(" 详情见")),t[32]||(t[32]=s("a",{href:"#内存分区"},"内存分区",-1)),t[33]||(t[33]=l("。"))]),t[35]||(t[35]=s("li",null,[l("分配的初始值是每种变量的默认值"),s("br"),l(" 就算人为在类中定义了初始值，但在准备阶段只会被分配这种类型的默认值。除非它被 "),s("code",null,"final"),l(" 修饰。")],-1))])])]),t[41]||(t[41]=s("li",null,[l("解析"),s("br"),l(" 将虚拟机常量池里的符号引用替换为直接引用。"),s("br"),l(" 符号引用指用符号来描述目标，可以是任何字面量；直接引用是直接指向目标的指针或相对偏移量或间接定位目标的句柄。"),s("br"),l(" 解析主要针对类、接口、字段、类方法、接口方法、方法句柄和调用限定符这七类符号引用。"),s("br"),l(" 通过将符号引用转换为直接引用，程序可以准确得知类、字段、方法等在内存中的指针或偏移量。")],-1))])]),t[44]||(t[44]=i("",3))]),t[48]||(t[48]=i("",34))])}const _=n(g,[["render",y]]);export{A as __pageData,_ as default};
