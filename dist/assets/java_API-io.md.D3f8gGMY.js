import{_ as l,c as a,o as i,ag as t}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"API-输入/输出类库 (Package java.io)","description":"","frontmatter":{"prev":{"text":"API-工具类库3","link":"java/API-util3"},"next":{"text":"Java 虚拟机","link":"java/jvm"}},"headers":[],"relativePath":"java/API-io.md","filePath":"java/API-io.md"}'),o={name:"java/API-io.md"};function d(c,e,r,n,s,u){return i(),a("div",null,e[0]||(e[0]=[t('<h1 id="api-输入-输出类库-package-java-io" tabindex="-1">API-输入/输出类库 (Package <code>java.io</code>) <a class="header-anchor" href="#api-输入-输出类库-package-java-io" aria-label="Permalink to &quot;API-输入/输出类库 (Package `java.io`)&quot;">​</a></h1><h2 id="_6-1-file类" tabindex="-1">6.1 <code>File</code>类 <a class="header-anchor" href="#_6-1-file类" aria-label="Permalink to &quot;6.1 `File`类&quot;">​</a></h2><h3 id="_6-1-1-基本信息" tabindex="-1">6.1.1 基本信息 <a class="header-anchor" href="#_6-1-1-基本信息" aria-label="Permalink to &quot;6.1.1 基本信息&quot;">​</a></h3><p><strong>Package</strong> java.io<br><code>public class File</code></p><ul><li>表示文件或者目录的类。</li><li>构造函数<code>File(String pathname)</code>可以用来构造一个文件。 <ul><li>目标文件不存在时不会创建</li><li>创建<code>File</code>对象时，不会在计算机中检查是否存在。只是将传入的路径标识为<code>File</code>对象。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><ul><li><p>Windows 下，使用<code>\\\\</code>分割目录；而 Linux 以<code>/</code>分割<br> 使用<code>File.separator()</code>来获取目录分隔符</p></li><li><p>Windows 下，使用<code>;</code>分割不同的路径；而 Linux 以<code>:</code>分割<br> 使用<code>File.pathSeparator()</code>来获取路径分隔符</p></li></ul></div></li></ul><h3 id="_6-1-2-重要方法" tabindex="-1">6.1.2 重要方法 <a class="header-anchor" href="#_6-1-2-重要方法" aria-label="Permalink to &quot;6.1.2 重要方法&quot;">​</a></h3><ul><li><p><code>createNewFile()</code><br> 创建文件。当文件不存在时，会创建新文件。<br> 要求文件存放路径真实存在。只能用于创建文件，但不能创建目录。</p></li><li><p><code>mkdir()</code><br> 只能用于创建目录。<br> 只能创建一层目录。</p></li><li><p><code>mkdirs()</code><br> 创建多层目录。</p></li><li><p><code>delete()</code><br> 删除文件/目录。从计算机中真正移除。<br> 若删除目录为目录，且该目录下有子目录或者文件时，则无法删除。</p></li><li><p><code>listFiles()</code><br> 获取文件、获取目录的子文件、子目录。<br> 以文件类对象数组形式返回。</p></li><li><p><code>isDirectory()</code><br> 判断是否为目录。</p></li><li><p><code>isFile()</code><br> 判断是否为文件。</p></li><li><p><code>getName()</code><br> 获取文件名。</p></li><li><p><code>canWrite()</code><br> 判断文件是否可写。</p></li></ul><h3 id="_6-1-3-路径" tabindex="-1">6.1.3 路径 <a class="header-anchor" href="#_6-1-3-路径" aria-label="Permalink to &quot;6.1.3 路径&quot;">​</a></h3><ul><li><p>绝对路径</p><ul><li>以盘符或者<code>/</code>开头的路径</li><li>使用<code>getAbsolutePath()</code>获取</li></ul></li><li><p>相对路径</p><ul><li>不以盘符或者<code>/</code>开头的路径</li><li><code>..</code>表示上一层目录</li><li>使用<code>getPath()</code>获取</li></ul></li></ul><p><strong>路径相关的其他重要方法</strong></p><ul><li><p><code>getParent()</code><br> 获取父目录。</p></li><li><p><code>lastModified()</code><br> 获取最后修改时间，返回值为自 1970/01/01 00:00:00 至最后修改时间的毫秒值。</p></li><li><p><code>setReadOnly()</code><br> 设置文件只读。</p></li><li><p><code>renameTo()</code><br> 重命名文件。<br> 若文件路径没有发生改变，则重命名；若改变则执行剪切。</p></li></ul><h2 id="_6-2-i-o-stream" tabindex="-1">6.2 I/O Stream <a class="header-anchor" href="#_6-2-i-o-stream" aria-label="Permalink to &quot;6.2 I/O Stream&quot;">​</a></h2><p><code>java.io</code>是一套用于传输数据的 API。根据数据传输方向、数据传输形式可以分为四类，以及他们的关系：</p><ul><li>根据数据传输方向：输入流、输出流<br> 输入流：当数据从外部流向程序。例如：读取文件，将数据文件读取到程序中。<br> 输出流：数据从程序流向外部。例如：向文件写数据，数据从程序流向文件。</li><li>根据数据的传输形式：字节流、字符流</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">输入流</th><th style="text-align:center;">输出流</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>字节流</strong></td><td style="text-align:center;"><code>InputStream</code></td><td style="text-align:center;"><code>OutputStream</code></td></tr><tr><td style="text-align:center;"><strong>字符流</strong></td><td style="text-align:center;"><code>Reader</code></td><td style="text-align:center;"><code>Writer</code></td></tr><tr><td style="text-align:center;">*这四个基本流都是抽象类。</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><ul><li>数据的一般来源和目的地有：硬盘、网络、输入设备和内存</li></ul><h3 id="_6-2-1-缓冲流" tabindex="-1">6.2.1 缓冲流 <a class="header-anchor" href="#_6-2-1-缓冲流" aria-label="Permalink to &quot;6.2.1 缓冲流&quot;">​</a></h3><ul><li><p><code>BufferedReader</code>类<br> 需要字符输入流作为参数，缓冲流仅提供缓冲区</p></li><li><p><code>BufferedWriter</code>类<br> 使用<code>newLine()</code>写入换行符</p></li></ul><h3 id="_6-2-2-字节流" tabindex="-1">6.2.2 字节流 <a class="header-anchor" href="#_6-2-2-字节流" aria-label="Permalink to &quot;6.2.2 字节流&quot;">​</a></h3><p>以字节形式读取数据，没有缓冲区。</p><h3 id="_6-2-3-转换流" tabindex="-1">6.2.3 转换流 <a class="header-anchor" href="#_6-2-3-转换流" aria-label="Permalink to &quot;6.2.3 转换流&quot;">​</a></h3><p>表层以字符形式，底层以字节形式。</p><ul><li><p><code>InputStreamReader</code>类<br> 转换输入流，将字节流转换为字符流</p></li><li><p><code>OutputStreamWriter</code>类<br> 转换输出流，将字节流转化为字符流<br> 例如：将数据写出 txt 文件：使用输出流，字符流，且和文件有关。故使用<code>FileWrite</code>(它是<code>OutputStreamWriter</code>的子类)</p><div class="tip custom-block"><p class="custom-block-title">关于 FileWriter</p><ul><li>使用构造函数<code>FileWriter(String path)</code>来创建新文件。</li><li>写出数据时并不直接写到文件中，而是写入缓冲区。<br> 缓冲区未满但代码已经运行结束 → <code>flush()</code>冲出。</li><li>使用<code>close()</code>关闭流对象。<br> 缓冲区未冲刷关闭流对象前，自动执行<code>flush()</code>。<br> 关闭流对象后，对象没有被释放 → 赋值为<code>null</code>，标识为可回收</li></ul></div></li></ul><h3 id="_6-2-4-系统-标准-流" tabindex="-1">6.2.4 系统（标准）流 <a class="header-anchor" href="#_6-2-4-系统-标准-流" aria-label="Permalink to &quot;6.2.4 系统（标准）流&quot;">​</a></h3><ul><li><code>System.in</code> 标准输入流</li><li><code>System.out</code> 标准输出流</li><li><code>System.err</code> 标准错误流</li></ul><h3 id="_6-2-5-打印流" tabindex="-1">6.2.5 打印流 <a class="header-anchor" href="#_6-2-5-打印流" aria-label="Permalink to &quot;6.2.5 打印流&quot;">​</a></h3><ul><li><p><code>PrintWriter</code>类<br> 字符流</p></li><li><p><code>PrintStream</code>类<br> 字节流</p></li></ul><h3 id="_6-2-6-合并流" tabindex="-1">6.2.6 合并流 <a class="header-anchor" href="#_6-2-6-合并流" aria-label="Permalink to &quot;6.2.6 合并流&quot;">​</a></h3><p><code>SequenceInputStream</code>类</p><ul><li>字节流，可以合并多个字节输入流</li><li>将多个字节输入流进行合并时，需要将其放到<code>Vector</code>集合，利用<code>Vector</code>集合产生一个<code>Enumeration</code>对象</li><li>利用<code>Enumeration</code>对象构造合并流对象</li><li>只有输入流，没有输出流</li></ul><h3 id="_6-2-7-序列化-反序列化" tabindex="-1">6.2.7 序列化/反序列化 <a class="header-anchor" href="#_6-2-7-序列化-反序列化" aria-label="Permalink to &quot;6.2.7 序列化/反序列化&quot;">​</a></h3><ul><li>序列化：将对象完成存储（持久化）。<code>ObjectOutputStream</code></li><li>反序列化：将序列化的对象还原。<code>ObjectInputStream</code></li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><ul><li>实现对象序列化，需实现<code>Serializable</code>接口<br> 接口中没有任何方法和属性，仅用来标识类产生的对象可以被序列化</li><li>被<code>static</code>/<code>transient</code>修饰的属性不会被序列化</li><li>每个类在序列化时都有版本号 <ul><li>没有手动指定，JVM 在编译时会自动计算版本号</li><li>手动指定则不再自动计算</li><li>对象在反序列化时会比较当前类中版本号和对象版本号是否一致</li></ul></li><li>集合和数组不能被序列化</li></ul></div><div class="danger custom-block"><p class="custom-block-title">特别的</p><p>Java 的序列化不是常用序列化手段，它存在以下问题：序列化产生的数据量大、速度慢、不能跨语言。</p></div><h3 id="_6-2-8-autocloseable" tabindex="-1">6.2.8 AutoCloseable <a class="header-anchor" href="#_6-2-8-autocloseable" aria-label="Permalink to &quot;6.2.8 AutoCloseable&quot;">​</a></h3><ul><li>当流实现了这个接口可以被自动关闭。</li><li>需要写在<code>try(// Codes goes here…)</code></li><li>当执行完毕会自动调用<code>close()</code></li></ul><h3 id="_6-2-9-异常处理" tabindex="-1">6.2.9 异常处理 <a class="header-anchor" href="#_6-2-9-异常处理" aria-label="Permalink to &quot;6.2.9 异常处理&quot;">​</a></h3><ul><li>将流对象放在<code>try</code>外定义并赋值<code>null</code>， 在<code>try</code>中初始化</li><li>在关闭之前判断对象是否初始化成功</li><li>将流强制置空，防止关流失败无法释放文件 在写完数据后手动添加<code>flush</code>，防止关流失败数据丢失</li></ul>',38)]))}const b=l(o,[["render",d]]);export{h as __pageData,b as default};
