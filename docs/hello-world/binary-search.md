# 二分查找
这篇文章讨论二分查找的总体概念，并在此基础上尝试探讨各个细节问题。如：更新 `mid` `high` 和 `low` 时 `+1` `-1` 对其效果的影响；边界值确定；变体情况处理。

## 基本概念
二分查找是一种时间复杂度为 `O(logn)` 级别的查找方式，其每轮搜索都会缩小一半的查询范围，可以把两集很大的数据用很少的查找次数来寻找到目标值。  

最简单版本的二分查找是基于有序无重复数列的查找方法：  
**Code**  
``` java {7,12,14}
public int binarySearch(int[] arr, int size, int target) {
    // 初始化
    int low = 0;
    int high = size - 1;

    // 循环迭代
    while(low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    // 无法找到
    return -1;
}
```
分析：  
情况枚举：  

+ 循环条件 (`<` 和 `<=`)  
  **条件：元素个数为偶数个；循环条件为 `<`；指针更新都为 `+1`：**  
  数组元素个数不同可能会造成过早跳出循环。  
  以数组 [3, 6, 8, 19, 25, 30] 为例来尝试。  
  ```
  size: 6; target: 19
  Iteration 1:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑     ↑          ↑
   l     m          h

  Iteration 2:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
            ↑   ↑   ↑
            l   m   h
  
  Iteration 3:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
            ↑
           lmh
  
  Jump out of loop;
  return -1;
  ```  
  可以发现，当数组元素个数为偶数个时，查询过程走到两个指针重合后就会跳出循环，而不会进入循环返回目标数的下标。  
  当元素个数为奇数个时则无此问题如：[3, 6, 8, 19, 25, 30, 32]。  
  ```
  size: 7; target 25
  Iteration 1:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
   ↑        ↑           ↑
   l        m           h

  Iteration 2:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
            ↑   ↑       ↑
            l   m       h
  return 4;
  ```

+ 指针变更 (`+1` 和 `-1`)
  当保持循环条件不变（即 `<=`），将 `low` 指针变更为与 上一次 `mid` 位置相等。以数组 [3, 6, 8, 19, 25, 30] 为例来尝试。  
  ```
  size: 6; target: 30
  Iteration 1:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑     ↑          ↑
   l     m          h

  Iteration 2:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
         ↑  ↑       ↑
         l  m       h
  
  Iteration 3:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
            ↑   ↑   ↑
            l   m   h
  
  Iteration 4:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
                ↑   ↑
               lm   h
  
  ...
  ```
  可以看出，当目标值为右边界时，程序因为 `mid` 位置无法进一步更新而进入死循环。

  ```
  size: 7; target: 32
  Iteration 1:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
   ↑        ↑           ↑
   l        m           h

  Iteration 2:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
            ↑   ↑       ↑
            l   m       h

  Iteration 3:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
                ↑   ↑   ↑
                l   m   h

  Iteration 4:
  [3, 6, 8, 19, 25, 30, 32]
  (0, 1, 2, 3,  4,  5,  6)
                    ↑   ↑
                    lm   h
  ```  

  当保持循环条件不变（即 `<=`），将 `high` 指针变更为与 上一次 `mid` 位置相等。以数组 [3, 6, 8, 19, 25, 30] 为例来尝试。  
  ```
  size: 6; target: 3
  Iteration 1:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑     ↑          ↑
   l     m          h

  Iteration 2:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑  ↑  ↑
   l  m  h
  
  Iteration 3:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑  ↑      
   lm h      

  ...
  ```
  可以看出，当目标值为左边界时，程序同样因为 `mid` 位置无法进一步更新而进入死循环。  

  当保持循环条件不变（即 `<=`），将 `high` 和 `low` 指针都变更为与 上一次 `mid` 位置相等。以数组 [3, 6, 8, 19, 25, 30] 为例来尝试。  
  ```
  size: 6; target: 3
  Iteration 1:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑     ↑          ↑
   l     m          h

  Iteration 2:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑  ↑  ↑
   l  m  h
  
  Iteration 3:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑  ↑      
   lm h      

  ...

  size: 6; target: 30
  Iteration 1:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
   ↑     ↑          ↑
   l     m          h

  Iteration 2:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
         ↑  ↑       ↑
         l  m       h
  
  Iteration 3:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
            ↑   ↑   ↑
            l   m   h
  
  Iteration 4:
  [3, 6, 8, 19, 25, 30]
  (0, 1, 2, 3,  4,  5)
                ↑   ↑
               lm   h
  
  ...
  ```
  可以看出，当边界值为左边界或右边界时，程序同样因为 `mid` 位置无法进一步更新而进入死循环。

  当修改循环条件（即 `<`），将 `low` 指针变更为与 上一次 `mid` 位置相等。以数组 [3, 6, 8, 19, 25, 30] 为例来尝试。

  
## 参考文献或资料