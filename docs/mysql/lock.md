---
prev: ./indices
next: ./reference
---

# 锁
为了解决并发操作可能会出现的问题，MySQL 提供了锁机制。根据加锁范围，分为全局锁、表级锁和行级锁。

## 全局锁
使用命令 `FLUSH TABLES WITH READ LOCK` 让整个库处于只读状态。之后其他线程的 DDL(数据定义语言，包括创建表、修改表等)、DML(数据操作语言，包括增、删、改)和更新类的事务的提交语句会被阻塞。  
使用 `UNLOCK TABLES` 解锁。  

### 使用场景
当在进行全库逻辑备份（所有记录查找并保存到文本）时，可以考虑使用全局锁。  
+ 必要性  
  可能会发生数据不一致。在不加全局锁的情形下，因为不同表之间执行顺序不同备份时间就不同。若一张表在备份时间差内进行了更新操作，则它会与已经备份的关联表数据不一致。  
  ::: tip 一个有限制条件的解决方案
  可以利用可重复读的事务来解决。在支持事务的引擎里，比如 InnoDB 提供了逻辑备份工具 mysqldump. 使用参数 `-single-transaction` 来使用它时会在导入数据前启动一个事务，保证视图的一致性。且由于多版本并发控制 （MVCC），在备份过程中可以进行更新操作。  
  :::
+ 缺点
  + 在主库备份时，FTWRL 会使得主库不能执行更新操作，业务停摆；  
  + 若是读写分离的主从库模式，从库备份时，从库不能执行主库同步的 binglog 导致主从延迟。

::: warning 关于设置全局只读的解决方法
使用 `set global readonly=true` 也可以使得整个库处于只读的状态，但会带来一些问题：
+ 在一些主从库中，会使用 readonly 作为逻辑判断是否是从库；  
+ 当客户端发生异常断开时，readonly 不会改变库的状态，依旧保持只读会导致库处于长时间不可写状态。 FTWRL 在发生断开时会自动释放全局锁，让库恢复可以正常更新的状态。
:::

## 表级锁
表锁分为两种：表锁和元数据锁。

### 表锁
使用 `LOCK TABLES $table READ/WRITE` 来对表进行锁定。它使用 `UNLOCK TABLES` 主动解锁或在客户端断开连接时自动释放锁。它不仅限制别的线程的读或写，也限制本线程的操作：  
+ 线程 A 对某表添加读锁，线程 A 和其他线程都不能对表进行写操作。同时线程 A 不可以读写其他未加锁的表；
+ 线程 A 对某表添加写锁，线程 A 可以对表进行写操作，其他线程对表读写都阻塞；

理解为共享读锁，独占写锁。表锁在没有更细粒度的锁出现前，是最常用的并发处理机制。  

### 元数据锁 (Metadata Lock) <Badge text="MySQL 5.5+"/>
元数据锁会在一个表被访问时自动加锁而不需要显示使用。它可以保证读写的正确性。MDL 在语句开始时申请，事务结束后释放。  
+ 当一个表在进行增删改查时会添加读锁，此时所有线程都可以正常读取元数据，不影响增删改查。（读锁之间不互斥，多个线程可以对同一张表进行增删改查）
+ 当一个表正在进行结构更改操作时加写锁，只有拥有锁的线程可以读写元数据，其他线程不能执行任何操作。（写锁与读锁、写锁与写锁互斥，保证结构变更安全性）

::: warning 增加或修改字段时的风险

:::  
