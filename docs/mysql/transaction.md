---
prev: ./
next: ./indices
---

# 事务
事务会保证一组数据库操作要么全都成功，要么全部失败。事务的支持是在引擎实现的。MyISAM 引擎不支持事务，InnoDB 引擎支持事务。  

**特性**  
+ 原子性 Atomicity  
+ 一致性 Consistency  
+ 隔离性 Isolation
+ 持久性 Durability

## 隔离性
在多事务同时执行时，可能会出现脏读、不可重复读和幻读的问题：  
+ 脏读：事务 B 在执行中读取到了事务 A 修改过但未提交的数据；
+ 不可重复读：事务 B 前后读取两次，在读第二次前事务 A 对数据进行了修改，导致事务 B 第二次读取时记录内容不一致；  
+ 幻读：事务 B 前后读取两次，在第二次读取前事务 A 增加或删除了记录，导致事务 B 第二次读取时获得的记录数量不一致；  

### 隔离级别
MySQL 给出了四个隔离级别，通过隔离级别来解决上面的问题：  
+ 读未提交：事务未提交时其所作更改就对其他事务可见；  
  直接返回记录最新值，不使用阅读视图。  
+ 读提交：事务提交后所做更改对其他事务可见；  
  阅读视图在每条 SQL 开始执行时创建。  
+ 可重复读：事务在执行过程中可见的数据与其启动时一致，未提交前所作更改其他事务不可见；  
  阅读视图在事务启动时创建，在整个事务期间使用该视图。 
+ 串行化：对同一记录根据需求加读锁和写锁，当锁冲突时需要等待前一事务执行完成后才能执行；  
  使用加锁的形式避免冲突。  

#### 并发版本控制
具体通过多版本并发控制 (MVCC) 来实现，不同时刻启动的阅读视图 (read-view).  
在 MySQL 中，每条更新记录会同时记录一条回滚操作到 undo log 中，记录中的最新值可以通过回滚来回到之前的状态。例如一串操作：1 → 2, 2 → 3, 3 → 4，对应的 undo log 是：2 → 1, 3 → 2, 4 → 3.  
假设在第一个更新创建了 read-view A, 在所有操作完成后创建了 read-view B. 对于 read-view A 来说，假如需要回到最原始的值 1，需要依次回滚所有操作；假如有新事务将当前值 4 修改为 5，这个操作对 read-view A,B 所在的事务不冲突。

示例：  
一条记录 r，当前值为 1.  
|事务 A|事务 B|读未提交|读提交|可重复读|串行化|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|R(r)||A: 1|A: 1|A: 1|A: 1|
||R(r)|B: 1|B: 1|B: 1|B: 1|
||W(r): 2|||||
|R(r)||A: 2|A: 1|A: 1|A: 1|
||Commit|||||
|R(r)||A: 2|A: 2|A: 1|A: 1|
|Commit||||||
|R(r)||A: 2|A: 2|A: 2|A: 2|

::: warning 特别的
+ 不同数据库的默认隔离级别不同，Oracle 的默认隔离级别是**读提交**，而 MySQL 的默认隔离级别是**可重复读**。在使用由 Oracle 数据库迁移到 MySQL 数据库的应用时需要修改隔离级别。启动时设置启动参数 `transaction-isolation` 为 `READ-COMMITTED`.  
  使用语句 `SHOW VARIABLES LIKE 'transaction-isolation';` 查看当前的隔离级别。  
+ 系统会在判断没有比当前 undo log 更早的 read-view 存在时删除该日志，所有不建议使用长事务。  
  长事务会导致在该事务提交前所有回滚记录都必须保留，占用很大存储空间。同时它也会占有锁资源。
:::

## 启动方式
1. 显示启动。
    使用 `begin transaction` 或者 `start transaction` 来启动，提交语句是 `commit`, 回滚语句是 `rollback`.
2. 设置关闭线程自动提交。
    使用 `set autocommit=0` 来关闭自动提交。当就算只执行一个 SELECT 语句时也会开启一个事务。这个事务只有当主动 commit 或 rollback，或者断开连接时才结束。  
    ::: warning 特别地
    为避免有些客户端框架在连接成功后自动执行 `set autocommit=0` 的命令造成长连接带来的长事务，推荐使用 `set autocommit=1` 并用显示的方式启动事务。  
    :::

### 提交并开启下一个事务
在显示使用事务的时候，可以使用 `commit workk and chain` 命令来提交当前事务并开启下一个事务。这样可以减少执行一次 `begin` 语句的交互开销，也可以知道每个语句是否在事务中。  

**查找长事务**  
使用命令来查找时间超过 60 秒的事务:  
``` SQL
SELECT * 
FROM information_schema.innodb_trx 
WHERE TIME_TO_SEC(timediff(now(),trx_started))>60;
```