import{_ as e,c as s,o as a,ag as i}from"./chunks/framework.DPDPlp3K.js";const k=JSON.parse('{"title":"关于索引的迷惑","description":"","frontmatter":{},"headers":[],"relativePath":"mysql/question.md","filePath":"mysql/question.md"}'),n={name:"mysql/question.md"};function l(d,t,c,p,o,r){return a(),s("div",null,t[0]||(t[0]=[i(`<h1 id="关于索引的迷惑" tabindex="-1">关于索引的迷惑 <a class="header-anchor" href="#关于索引的迷惑" aria-label="Permalink to &quot;关于索引的迷惑&quot;">​</a></h1><h2 id="已知资料" tabindex="-1">已知资料 <a class="header-anchor" href="#已知资料" aria-label="Permalink to &quot;已知资料&quot;">​</a></h2><p>在 InnoDB 引擎中，采用了 B+ 树的形式才建立索引。对于同一张表，会建立两个索引：主键索引和非主键索引。</p><ul><li>主键索引<br> 也称为聚簇索引 (Clusterd Index)。以主键值建立树，叶子结点存储整行数据。</li><li>非主键索引<br> 也称为二级索引 (Secondary Index)。以索引列建立树，叶子结点存储主键的值。</li></ul><p>在具体查询过程中，如果采用主键进行查询的方式，则使用聚簇索引直接查找；若采用值查询的方式，则先在对应列的树中搜索，再根据得到的 ID 在聚簇索引中搜索，称为回表。由于回表需要查询两颗索引树，所以一般尽量使用主键查询。</p><h2 id="课程例子" tabindex="-1">课程例子 <a class="header-anchor" href="#课程例子" aria-label="Permalink to &quot;课程例子&quot;">​</a></h2><p>有表：</p><table tabindex="0"><thead><tr><th style="text-align:center;">id</th><th style="text-align:center;">k</th><th style="text-align:center;">name</th></tr></thead><tbody><tr><td style="text-align:center;">100</td><td style="text-align:center;">1</td><td style="text-align:center;"><code>null</code></td></tr><tr><td style="text-align:center;">200</td><td style="text-align:center;">2</td><td style="text-align:center;"><code>null</code></td></tr><tr><td style="text-align:center;">300</td><td style="text-align:center;">3</td><td style="text-align:center;"><code>null</code></td></tr><tr><td style="text-align:center;">500</td><td style="text-align:center;">5</td><td style="text-align:center;"><code>null</code></td></tr><tr><td style="text-align:center;">600</td><td style="text-align:center;">6</td><td style="text-align:center;"><code>null</code></td></tr></tbody></table><p>给字段 k 设置了索引</p><h2 id="疑惑" tabindex="-1">疑惑 <a class="header-anchor" href="#疑惑" aria-label="Permalink to &quot;疑惑&quot;">​</a></h2><blockquote><p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p></blockquote><p>实际运行:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EXPLAIN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	\`data\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span></span></code></pre></div><p>结果： <code>Extra null</code><br> 与预期不符。</p><blockquote><p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p></blockquote><p>实际运行:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EXPLAIN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	\`data\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre></div><p>结果： <code>Extra null</code><br> 与预期不符。</p><div class="warning custom-block"><p class="custom-block-title">疑问</p><ul><li>经过试验，如果 <code>SELECT</code> 的不是 <code>*</code> 而是 <code>id</code> 或者 <code>k</code> 时，<code>EXPLAIN</code> 的结果会变成 <code>Using index</code>;</li><li>经过试验，如果更换表设计，去掉字段 <code>name</code>，仅保留 <code>id</code> 和 <code>k</code> 时，再重复上面两个查询语句，第二个语句结果会变成 <code>Using index</code>;</li></ul><p>问题一是<strong>控制使用索引与否的到底是什么</strong>，按照实验一，可以猜测是“在多字段情况下，给单个非主键字段设置索引，使用索引与否由 <code>SELECT</code> 项控制。只有查询字段是被索引包含的才会使用；<br> 但是第二个实验在更新表设计后，在通配查询也使用了索引，破除了上面的猜想。<br> 造成上面情况的原因是什么？</p><p>问题二是<strong>为什么语句一在 <code>Explain</code> 后显示为 <code>null</code></strong>？</p></div>`,19)]))}const g=e(n,[["render",l]]);export{k as __pageData,g as default};
