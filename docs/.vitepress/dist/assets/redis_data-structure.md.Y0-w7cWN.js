import{_ as i,c as e,o as a,ag as t}from"./chunks/framework.DPDPlp3K.js";const r="/img/redis/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg",p=JSON.parse('{"title":"数据结构","description":"","frontmatter":{"prev":{"text":"集群","link":"redis/cluster"},"next":{"text":"持久化","link":"redis/persistence"}},"headers":[],"relativePath":"redis/data-structure.md","filePath":"redis/data-structure.md"}'),s={name:"redis/data-structure.md"};function u(n,l,d,o,h,c){return a(),e("div",null,l[0]||(l[0]=[t('<h1 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h1><p>Redis 包含五个数据结构。分别是 String, List, Hash, Set 和 Sorted Set. 除了 String 以外，其他四种是集合类型，因为它们一个键对应一个集合的数据。</p><h2 id="全局哈希表" tabindex="-1">全局哈希表 <a class="header-anchor" href="#全局哈希表" aria-label="Permalink to &quot;全局哈希表&quot;">​</a></h2><p>在 Redis 中，为了组织所有的键值对，它维护了两张全局哈希表。<br> 哈希表是一个数组，每个元素称为一个哈希桶，哈希桶中不保存元素本身，而保存指向具体 entry 的指针。每一个 entry 由键值对构成，可以通过指针被访问到。<br> 利用了这样的全局哈希表，就可以在 O(1) 的时间复杂度中找到键值对。</p><p><img src="'+r+'" alt="全局哈希表"></p><h3 id="哈希冲突" tabindex="-1">哈希冲突 <a class="header-anchor" href="#哈希冲突" aria-label="Permalink to &quot;哈希冲突&quot;">​</a></h3><p>但是随着数据变多，因为哈希冲突和 rehash, 可能会带来操作阻塞。<br> 当发生哈希冲突时，Redis 采用链式哈希的操作来解决冲突。同一个哈希桶用链表的形式保存多个元素。</p><p>当数据逐渐增加，链表会导致性能下降时，它会通过 rehash 启用第二张全局哈希表。rehash 过程为：</p><ul><li>给第二张全局哈希表分配空间，大小是第一张的两倍</li><li>将第一张全局哈希表中的数据重新映射到第二张中</li><li>释放第一张全局哈希表的空间</li></ul><p>为了避免第二步中数据映射可能带来的巨大开销，Redis 的 rehash 过程是渐进式的。即在映射过程中，Redis 仍然正常处理客户端请求。每处理一个请求，就通过键找到对应的第一张全局哈希表中的哈希桶位置，并将其所有 entry 都拷贝到第二张全局哈希表中。<br> 通过这样的操作分摊了一次高开销的操作，并且保证了数据的快速访问。</p><h2 id="内置数据结构与底层实现" tabindex="-1">内置数据结构与底层实现 <a class="header-anchor" href="#内置数据结构与底层实现" aria-label="Permalink to &quot;内置数据结构与底层实现&quot;">​</a></h2><h3 id="内置数据结构" tabindex="-1">内置数据结构 <a class="header-anchor" href="#内置数据结构" aria-label="Permalink to &quot;内置数据结构&quot;">​</a></h3><ul><li>String <ul><li>底层实现：简单动态字符串</li></ul></li><li>List <ul><li>底层实现：压缩列表；双向链表</li></ul></li><li>Hash <ul><li>底层实现：压缩列表；哈希表</li></ul></li><li>Set <ul><li>底层实现：整数数组；哈希表</li></ul></li><li>Sorted Set (ZSet) <ul><li>底层实现：压缩列表；跳表</li></ul></li></ul><h3 id="底层实现" tabindex="-1">底层实现 <a class="header-anchor" href="#底层实现" aria-label="Permalink to &quot;底层实现&quot;">​</a></h3><ul><li>压缩列表 <ul><li>类似数组，每一个位置保存一个数据。</li><li>表头有三个字段：zlbytes, 列表长度； zltail, 列表尾偏移量；zllen, 列表 entry 个数.</li><li>表尾有一个字段：zlend, 列表结束。</li><li>当查找第一个和最后一个元素时，利用表头三个字段直接定位，时间复杂度 O(1)</li><li>当查找其他元素时，时间复杂度 O(n)</li></ul></li><li>跳表 <ul><li>在链表的基础上，增加了多级索引。通过索引位置进行跳转来快速定位。</li><li>时间复杂度为 O(logN)</li></ul></li></ul><h2 id="操作的时间复杂度" tabindex="-1">操作的时间复杂度 <a class="header-anchor" href="#操作的时间复杂度" aria-label="Permalink to &quot;操作的时间复杂度&quot;">​</a></h2><ul><li>单元素操作<br> 对单个元素的操作 <ul><li>O(1) <ul><li>Hash: HGET, HSET, HDEL</li><li>Set: SADD, SREM, SRANDMEMBER</li></ul></li></ul></li><li>范围操作<br> 对集合遍历操作，时间复杂度为 O(n). 但在 Redis 2.8 提供的 SCAN 操作下采用渐进式遍历，可以避免阻塞。 <ul><li>O(n) <ul><li>Hash: HGETALL</li><li>Set: SMEMBERS</li><li>List: LRANGE</li><li>Sorted Set: ZRANGE</li></ul></li></ul></li><li>统计操作 <ul><li>统计集合中元素个数，时间复杂度为 O(1). 例如：LLEN, SCARD</li></ul></li><li>例外情况 <ul><li>利用压缩列表和双向列表的头尾偏移量的操作时间复杂度都为 O(1). 例如：LPOP, RPOP, LPUSH, RPUSH</li></ul></li></ul>',17)]))}const _=i(s,[["render",u]]);export{p as __pageData,_ as default};
