import{_ as a,c as r,o as t,ag as i}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"Redis","description":"","frontmatter":{"prev":false,"next":{"text":"缓存","link":"redis/cache"}},"headers":[],"relativePath":"redis/index.md","filePath":"redis/index.md"}'),s={name:"redis/index.md"};function d(n,e,o,l,c,_){return t(),r("div",null,e[0]||(e[0]=[i('<h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h1><p>Redis 是一种 NoSQL.</p><h2 id="多路复用机制" tabindex="-1">多路复用机制 <a class="header-anchor" href="#多路复用机制" aria-label="Permalink to &quot;多路复用机制&quot;">​</a></h2><p>在 Redis 中，其对外提供键值对存储服务的主要流程，例如：网络 IO 和 键值对读写是由一个线程完成的。所以我们理解为 Redis 具有单线程高性能。但它在持久化、异步删除和集群数据同步等操作时是由其他线程执行的。</p><p>Redis 在只运行单线程的情况下，允许内核中同时存在多个监听套接字和已连接套接字。这样，内核就会持续监听这些套接字上的连接请求和数据请求，只要有请求到达就交给 Redis 线程处理。<br> 当请求到达时，多路复用机制提供了基于事件的回调机制，即针对不同事件发生，调用相应的处理函数。事件会被放进事件队列中，Redis 单线程对事件队列进行处理。这样即可实现 Redis 无需一直轮询是否有请求实际发生，避免造成 CPU 资源浪费。</p><h2 id="参考文献或资料" tabindex="-1">参考文献或资料 <a class="header-anchor" href="#参考文献或资料" aria-label="Permalink to &quot;参考文献或资料&quot;">​</a></h2><p>[1] 蒋德钧.<a href="https://time.geekbang.org/column/100056701" target="_blank" rel="noreferrer">Redis 核心技术与实战</a>. 2020</p>',7)]))}const f=a(s,[["render",d]]);export{h as __pageData,f as default};
