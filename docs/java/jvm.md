---
prev: ./API-io
next: ./references
---

# Java 虚拟机
Java 中使用范围最广的虚拟机就是 HotSpot 虚拟机，这里介绍相关的知识。  

## 内存分区
![内存分区](/img/内存模型.png)

+ 程序计数器  
  是寄存器，负责程序计数和任务调度。  
  虚拟机中的字节码解释器通过改变程序计数器来依次读取指令，以此实现代码流程控制。  
  在多线程情况下，程序计数器记录当前线程执行位置，当线程切换时可以获得运行位置信息。  
  生命周期随着线程的创建而创建，随着线程的结束而死亡。  

+ 本地方法栈  
  描述本地（原生）方法执行的内存模型。  
  本地方法被执行的时候，在本地方法栈会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。  
  可能会出现 StackOverFlowError 和 OutOfMemoryError.  

+ 栈内存（虚拟机栈）  
  描述 Java 方法（字节码）执行的内存模型，每次方法调用的数据都是通过栈传递的。  
  由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。  
  其中最重要的是局部变量表，它主要存放编译器可知的各种数据类型和对象引用。  
  每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束或抛出异常后，都会有一个栈帧被弹出。  
  StackOverFlowError：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。  
  OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 错误。

+ 堆内存  
  存储对象（对象生命周期结束后被 `GC` 回收，堆也被成为 GC 堆），对象实例和数组会被分配在这里。  
  堆内存分为：新生代，老年代和永久代。其中新生代包括伊甸园区（Eden）和两个幸存区（Survivor, S0, S1）  
  可能会出现 OutOfMemoryError, 具体还分为 GC Overhead Limit Exceeded, Java heap space 等情形。  

+ 方法区  
  存储类的信息（已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）  
  虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。  
  方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口。而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。  
  方法区溢出会报 `OutOfMemoryError` 错误  
  方法区中垃圾回收行为很少出现，可以用以下命令对该分区大小进行调节：  
  ``` java
  -XX:PermSize=N //方法区 (永久代) 初始大小
  -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError
  ```
  其中：  
  + 静态区  
    存储静态属性和静态方法  
    静态属性存储在此区后自动赋默认值

  + 静态常量池  
    存储类成员属性和成员方法信息  

  + 运行时常量池  
    存储计算机常量和被 `final` 修饰的常量副本
    逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。<Badge type="error" text="Java 7.0-"/>  
    运行时常量池剩下的东西还在方法区（永久代）中，但字符串常量池被从方法区拿到了堆中。<Badge type="warning" text="Java 7.0"/>  
    移除了永久代而用元空间取代, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间。<Badge text="Java 8.0+"/>  

+ 直接内存  
  直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。  
  可能导致 OutOfMemoryError.  
  JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。<Badge text="Java 1.4+"/>

其中堆内存、方法区与直接内存是所有线程共享的，而栈内存（虚拟机栈）、本地方法栈与程序计数器是每个线程独有的。  

在Java 8 后，虚拟机对内存分配有了更新<Badge text="Java 8.0+"/>：  
![内存模型 1.8](/img/内存模型1_8.png)
在 Java 8 之后，通过合并 HotSpot 与 JRockit 虚拟机，永久代被元空间代替，而元空间使用直接内存。  
使用命令来调节元空间大小：  
``` java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
MetaspaceSize 默认值为 unlimited，意味着它只受系统内存的限制；MetaspaceSize 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。  
元空间里面存放的是类的元数据，通过使用元空间而不是永久代来增加可加载类的数量。（仅受机器实际可用空间限制）  

::: tip 对象生命周期结束的判定
堆内存中有两个机制可以检测对象声明周期是否结束。  
1. 引用计数法  
   给对象添加一个引用计数器，当出现一个引用时计数器加一，当引用失效时计数器减一。当计数器为零时对象声明周期结束。  
   但主流 JVM 并不采用这个机制，因为它无法解决对象循环引用问题。  
2. 可达性分析算法  
   设定一些对象成为 GC Roots。从 GC Roots 开始向下搜索，所有走过路径称为引用链。当某对象没有从 GC Root 到该对象的引用链时，即处于不可达状态。这些对象需要被回收。  
   不可达的对象会经过两个阶段：  
   1. 被判定不可达后被进行标记
   2. 被标记过一次的对象被进行筛选，如果有必要进行 `finalize()` 则被回收。 （对象没有调用 `finalize()` 或这个方法已经被虚拟机调用过时认为不需要执行 `finalize()`)  
   可以作为 GC Root 的对象有：  
   + 栈内存中引用的对象（栈帧中的本地变量表）  
   + 本地方法栈中引用的对象  
   + 方法区中类的静态属性引用的对象
   + 方法区中常量引用的对象
   + 被同步锁持有的对象
:::

## 垃圾分代回收机制
对象在堆内存中存储。当对象在使用完成后，会在某个不定的时刻被垃圾回收器 `GC` 解析。  
值得注意的是：**垃圾回收过程无法手动控制**。  
基本逻辑：  
+ 堆内存分为**新生代区**，**老年代区**和**永久代**。  
+ 新生代区分为**伊甸园区**和两个**幸存区**。  
+ 幸存区包括两个部分，S0(From) 和 S1(To).  
+ 一个新创建的对象会被生成在伊甸园区，若在伊甸园区的对象经过一次回收过程仍然存活，则被移动到幸存区。  
+ 幸存区的回收扫描频率略低于伊甸园区。在幸存区经过多次扫描，若对象仍然存活，则被移动到老年代区。
+ 老年代区的回收扫描频率会远远低于新生代区。
+ 当老年代区中的对象被回收时，会导致程序卡顿甚至崩溃。
+ GC 分为两大类：  
  + Partial GC
    + Minor GC (Young GC): 只对新生代进行垃圾回收，当伊甸园区满时触发
    + Major GC (Old GC): 只对老年代进行垃圾回收
    + Mixed GC: 对整个新生代和部分老年代进行垃圾回收
  + Full GC: 对整个堆和方法区进行垃圾回收，当准备触发 Minor GC 但是预估平均晋升比老年代剩余空间大时触发；当永久代满时触发；当执行 `System.gc()` 和 Heap Dump 时触发

### 具体逻辑
**一般情况**  
+ 对象在伊甸园区分配
+ 伊甸园区垃圾回收后仍然存活的对象进入 S0 或 S1，其年龄变为 1
+ 每轮垃圾回收后仍然存活的对象年龄加 1
+ 当年龄大于 15 （默认情况）的对象转移到老年代  
  `-XX:MaxTenuringThreshold` 设定阈值年龄大小；  
  `-XX:+PrintTenuringDistribution` 打印当前次垃圾回收后阈值年龄。  
  动态年龄阈值计算机制：  
  虚拟机遍历所有对象统计它们的年龄，按小到大对年龄出现频率进行累积计算。当某年龄开始累积对象总大小超过幸存区容量一半时，取该年龄和 MaxTenuringThreshold 中更小的作为新的阈值年龄。  
+ 若某次垃圾回收后伊甸园区和 S0 区被清空，则 S1 与 S0 交换角色。  
+ 若某次垃圾回收后 S0 区空间不够但某些对象还没有达到进入老年代条件，无法存下的部分提前进入老年代。（分配担保机制）  

### 垃圾回收算法
1. 标记-清除算法  
   先标记出不需要回收的对象，之后统一回收掉没有被标记的对象。  
   问题：  
   + 效率低  
   + 产生不连续的碎片导致空间利用率低  
2. 标记-复制算法  
   将内存分为大小相同的两块，每次使用其中一块。当当前使用的内存不足时，标记出不需要回收的对象并复制到第二块内存中。之后一次性清除掉第一块内存中所有空间。  
3. 标记-整理算法  
   根据老年代特性提出的算法。标记出不需要回收的对象并让它们移向一端，之后清除掉边界以外的内存空间。  
4. 分代回收算法  
   [具体逻辑](#垃圾分代回收机制)。综合利用上面的算法。  
   在分代的基础上，在新生代中选择标记复制算法，只需要付出少量对象复制成本就可以在高频率对象生命周期结束的情况下完成垃圾回收。  
   在老年代使用标记-清除或标记-整理算法，它们的生命周期更长，没有额外的空间可以分配担保。  

### 垃圾回收器
垃圾回收器是垃圾回收算法的具体实现。需要在具体场景选用最合适的垃圾回收器。  
1. Serial  
   + 串行收集器，单线程。在进行垃圾回收时，其他工作线程都需要暂停，直到收集结束。  
   + 垃圾回收算法：新生代采用标记-复制算法，老年代采用标记-整理算法。  
   + 优点：简单高效，没有线程交互开销。适用于 Client 模式下的虚拟机。  
   + 缺点：Stop-The-World 的巨大停顿影响程序体验。  
2. ParNew  
   + Serial 的多线程版本。（用户线程等待，垃圾回收器并行执行，直到回收结束后用户线程继续）除使用多线程外，其他行为和 Serial 相同。  
   + 垃圾回收算法：新生代采用标记-复制算法，老年代采用标记-整理算法。  
   + 适用于 Server 模式下的虚拟机。可以与 CMS 回收器配合工作。  
3. Parallel Scavenge  
   + Java 7 的默认垃圾回收器。  
   + 拥有高吞吐的特性（高效利用 CPU, CPU 中用于运行用户代码的时间与 CPU 总消耗时间比值高）  
   + 用户线程等待，垃圾回收器并行执行，直到回收结束后用户线程继续。  
   + 垃圾回收算法：新生代采用标记-复制算法，老年代采用标记-整理算法。  
4. Serial Old  
   + Serial 老年代版本。  
   + 用于在 Java 8 和以前的版本中搭配 Parallel Scavenge 使用；或作为 CMS 的备选方案。  
5. Parallel Old  
   + Parallel Scavenge 的老年代版本。  
6. CMS  
   + Concurrent Mark Sweep 收集器。以获取最短回收停顿为目标，提高用户体验。 
   + 是 HotSpot 虚拟机的第一款真正意义上的并发收集器。  
   + 实现垃圾回收线程与用户线程几乎同时工作。  
   + 垃圾回收算法：使用标记-清除算法，具体步骤为  
      + 初始标记  
        暂停其他线程，记录直接与 Root 相连的对象  
      + 并发标记  
        同时开启 GC 线程与用户线程。用闭包结构记录可达对象。  
        （闭包结构中不具有实时性。它不会包含全部可达对象，因为用户线程可能会不断更新引用。算法会跟踪记录引用更新的地方）  
      + 重新标记  
        用户线程暂停，GC 线程修正并发标记期间引用更新的地方。  
        停顿时间比初始标记时间稍长，比并发标记时间短。  
      + 并发清除  
        开启用户线程，GC 线程开始对未标记区域清除。  
      + 并发重置  
  + 优点：并发收集、低停顿。  
  + 缺点：对 CPU 资源敏感；无法处理浮动垃圾；使用标记-清除算法带来空间碎片化。  
7. G1  
   + Garbage First 垃圾回收器，是 Java 9 的默认垃圾回收器。  
   + 面向服务器的垃圾回收器，针对配备多颗处理器和大容量内存的机器。  
   + 极高概率满足 GC 停顿时间小且高吞吐。  
   + 四个特点：  
     1. 并发与并行  
        利用多 CPU 特性来缩短 Stop The World 时间（并行）。  
        利用并发在本需要停顿用户线程来执行 GC 任务的情况下同时运行。    
     2. 分代回收  
        保留分代概念，但不需要其他垃圾回收器配合。  
     3. 空间整合  
        整体来看使用标记-整理算法；从局部来看使用标记-复制算法。  
     4. 可预测停顿  
        可以建立一个长度为几毫秒的停顿时间预测供使用者使用。  
   + 执行步骤：  
     G1 在后台维护了一个优先列表。每次根据允许的收集时间优先选择回收价值最大的区域（Region）。  
     通过使用划分区域的方式，保证 G1 在有限时间内尽可能提高收集率。  
     1. 初始标记
     2. 并发标记
     3. 最终标记
     4. 筛选回收
8. ZGC  
   + Java 11 中提供的一款新的垃圾回收器。  
   + 适用于大内存低延迟服务的内存管理与回收。  
   + 垃圾回收算法：标记-复制算法。  

## 类加载机制
### 生命周期
一个类的声明周期包括：  
1. 加载
2. 连接
   1. 验证
   2. 准备
   3. 解析 
3. 初始化
4. 使用
5. 卸载

### 双亲委派机制

## 对象操作机制
### 对象创建
当 JVM 遇到需要通过 `new` 创建对象时：  
1. 类加载检查  
   JVM 先检查该指令的参数能否在常量池中定位到被加载、解析、初始化过。若没有，则执行相应的类加载过程。
2. 分配内存  
   类检查后即可确定所需要的内存大小，JVM 按照堆内存是否规整（由 GC 使用的算法决定）选择一种内存分配方式进行内存分配：  
   + 指针碰撞  
     适合堆内存规整的情况。  
     将使用过的内存放在一边，未使用过的放在另一边，两个区域通过分界指针隔开。使用时指针向未使用过区域移动需要的内存大小。  
     对应 GC：Serial, ParNew  
   + 空闲列表  
     适合堆内存不规整的情况。  
     JVM 维护一个空闲内存列表。当需要空间时寻找一块可以存放的内存位置分给对象，之后更新列表。  
     对应 GC: CMS  
   ::: tip 并发内存分配下的线程安全
    JVM 通过两个机制来保证线程安全：  
    + CAS + 失败重试   
      每次操作不加锁，假设没有冲突直接完成某操作。当因为冲突而失败时就进行重试，直到成功为止。  
    + TLAB  
      为每个线程预先在伊甸园区划分一块 TLAB 内存。当 JVM 在给线程中对象分配内存时首先分配在 TLAB 内存中，若对象所需内存大于 TLAB 剩余内存或 TLAB 内存已耗尽时，再采用 CAS + 失败重试机制。  
   ::: 
3. 初始化值  
   JVM 对分配的内存初始化为默认值。（保证对象的实例属性在 Java 代码中可以不赋予初始值而直接使用）。  
4. 设置对象头  
   JVM 继续对对象进行设置，将相关的重要信息（对象所对应的具体类、类的元数据信息路径、哈希码、GC 分代年龄等）存放在对象头中。根据 JVM 运行状态不同 ，对象头设置方式可能会因为是否启用偏向锁等因素而产生不同的设置方式。  
5. 执行 `init` 方法  
   通过执行  `init` 方法使得具体对象初始化为程序员意愿状态。   

### 内存布局
一个对象在内存中可分为三块：  
1. 对象头  
   对象头包含两部分信息：  
   + 运行时数据：哈希码、GC 分代年龄、锁状态等
   + 类型指针：对象指向类的元数据指针。JVM 通过这个指针来确定对象属于那一个类。
2. 实例数据  
   真正存储的有效信息，定义的属性内容会被存放在这里。  
3. 对齐填充  
   起占位作用。HotSpot 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍。当实例数据没有对齐时，使用对齐填充来补全。  

### 访问定位
Java 程序通过栈内存中的引用数据来操作堆中的具体对象。主流的访问方式包括：  
+ 句柄  
  堆内存中划分一块区域成为句柄池，栈内存中的引用数据存储的是对象的句柄地址。句柄中存储了对象实例数据和类型数据的地址。  
  在对象被移动时只会改变句柄中的指针而不需要改变栈内存中的引用。  
+ 指针  
  由堆内存直接管理类型数据等信息，栈内存中的引用数据存储的直接是对象地址。  
  访问速度更快，节省了一次指针定位的时间开销。  