---
prev: ./语法
next: false
---

# 面向对象
## 概述
### 面向过程
面向过程注重过程，强调完成这个过程的具体动作。  
其设计理念是[自顶向下，逐步求精](./语法.html/#顺序结构)的。

### 面向对象
面向对象 (Object-Oriented) 注重对象，当我们拥有这个对象时，我们就拥有了这个对象所具有的一切功能。  
面向对象技术最大的三个特征是：**封装**，**继承**和**多态**。

## 类和对象
### 类
类 (Class) 是 Java 程序设计语言的基础。  
类似于显示生活中“种类”的概念，Java 中的类也是一种对某类事物进行抽象和归并。  
我们对某类事物进行抽象分析，去粗取精，由表及里，判断出这类事物最本质的特征，并用 Java 中预定的手法进行表述，就形成了一个类。  
一个类包含两大内容：**属性**和**方法**（也称“**成员变量**”和“**成员方法**”）。

::: tip 成员变量和局部变量的区别
1. 定义位置不同：
   * 成员变量是定义在类内方法外

   * 局部变量是定义在方法或者语句内部

2. 作用域不同：
   * 成员变量作用域整个类

   * 局部变量只能在定义的方法或者语句内部使用

3. 内部存储位置不同：
   * 成员变量存在堆内存中，并且在堆内存中自动的赋予默认值

   * 局部变量是存储在栈内存中，不会自动给值

4. 生命周期不同：
   * 成员变量是随着对象的创建而加载到堆内存中，随着对象的回收而释放;

   * 局部变量在方法或者语句执行的时候才会创建，随着方法或者语句的结束而立即移除栈内存
:::

### 对象
对象 (Object) 是对类的实例化。  
我们可以通过某类的具体对象来进行具体操作。  
使用`new`关键字可以创建新的对象，使用`.`运算符获取并使用该对象所具有的方法。  
对象在程序中传递时，传递的是引用地址而不是数据本身。

### `this`
+ `this`关键字  
  + `this`关键字可以表述一个对当前对象自身的引用。  

  + 在本类中使用`this`可以调用本类的**非静态方法**和**非静态属性**。

+ `this()`语句  
  + 表示在本类的构造方法中调用**本类**的其他的对应形式的构造函数。  

  + 必须放在构造函数的第一行。

### `super`
+ `super`关键字
  + `super`关键字用以表示对父类对象的引用。

  + 表示在子类中调用父类中的方法和属性。

+ `super()`语句
  + 表示子类的构造方法中，调用父类中对应形式的构造方法。

  + 必须写在子类构造函数的第一行。

  + 每一个子类的构造函数都直接或间接的含有`super()`语句。  

  + 如果父类中没有提供无参构造，那么此时子类的构造函数中必须手动添加一个`super()`语句。

## 方法
方法 (Method) , 也称为函数。  
为实现代码复用，需要将代码进行封装。这种封装的形式就是方法。  
方法在定义好之后，必须明确返回值类型。若方法有明确的返回值类型，还要确保方法有返回值。  

**作用**：
+ 提高代码复用性。  

+ 使代码结构更加清晰。

+ 便于模块化开发。

**方法签名**：一个方法由其修饰符、返回值类型、方法名和形式参数唯一确定，这一组数据称为方法签名。

### 构造方法
与类同名且没有返回值类型。  
可以被重载。  
构造函数中可以存在`return`语句，用于规避不合理的数据。  
**作用**：用于创建对象（标识对象创建的开始和结束）

### 方法的使用
+ 方法递归  
  **核心**：方法调用自己本身  
  ::: warning 注意 
  需要控制好结束条件，若递归层数太深，则出现栈溢出错误。
  :::

+ 方法重载 (Method Overload)  
  详见[多态](#多态)。
  
+ 方法覆盖 (Method Override)  
  详见[多态](#多态)。

::: warning 注意
在传递参数的时候，对于基本类型而言，传递的实际值；对于引用类型而言，传递的是地址。  
例如在传递数组对象时，只要地址不发生改变，方法中的一切变化会作用于原数组。
:::

## 代码块
### 构造代码块
+ 定义在类内。  

+ 也称“初始化代码块”，在创建对象时执行构造方法之前先执行。  

+ 用于完成一些初始化的操作。

### 局部代码块
+ 定义在方法或代码块中。  

+ 限制变量的生命周期和使用范围。  

+ 可以提高内存的利用率。

## 包
包是类的容器，提供了解决命名空间冲突的方案。  
### 包的声明  
  - 使用`package`关键字声明定义一个包。  

  - 一个`.java`文件只允许存在一个`package`语句。  

  - 包的声明必须放在`.java`文件的首行。  

### 包的导入  
  - 使用`import`关键字来导入别的包。  
  
  - `*`为通配符，表示导入该包下所有类（不包括子包中的类）。  

### JDK 常用包  
  - `java.lang`：核心包，在程序启动时自动加载到方法区，不需要手动导入  

  - `java.util`：工具包，存放简化操作的工具类

  - `java.io`：数据传输

  - `java.net`：网络传输

  - `java.math`：数学运算

  - `java.sql`：数据库相关

  - `java.awt`：图形用户界面

  - `java.security`：数据安全

  - `javax.xxx`：扩展

  - `org.xxx`：第三方厂商、开源社区提供的包

::: warning 注意
+ 包名不能以`java`、`javax`或者`org`开头。  

+ 同包，或`lang`包下的类不使用`import`语句导入
:::

## 封装
将一个事物的相关信息聚集在一个逻辑单元内部的机制就是封装。  

**形式**：方法、属性私有化（类的封装）、内部类等。  

**优点**：提高复用性和安全性，使代码结构更加紧密。

## 继承
对于两个类 A 和 B 来说，它们之间的关系是：B 由 A 派生而来（对于 B 类来说，它拥有 A 类的所有属性和方法），则可以说 B 类继承自 A 类。

### 形式
使用`extends`关键字实现继承。  
Java 仅支持单继承（一个子类只能有一个父类）。

### 单继承与多继承
+ 单继承  
  子类只能有一个父类的继承形式。 

  **优点**：
    + 可以提高代码的复用性  

    + 可以避免方法调用的混乱，提高了方法调用的安全性
  
+ 多继承  
  子类可以拥有多个父类的继承形式。  

  **优点**：
    + 代码的复用性上要优于单继承

+ 举例  
  + `iPhone 类`仅继承自`智能设备类`。（单继承）  

    ![单继承](/img/单继承.jpg)

  + `Apple Watch 类`同时继承自`时钟类`和`只能设备类`。（多继承）  
    
    ![多继承](/img/多继承.jpg)

### 直接继承与间接继承
+ 直接继承  
  B 类直接派生于 A 类，称直接继承。

+ 间接继承
  B 类直接派生于 A类，C 类直接派生于 B 类。则称 C 类间接继承于 A 类。  
  ![间接继承](/img/间接继承.jpg)

## 多态
+ 当众多对象接收到同一个消息后，可以产生不同的响应效果，这种现象称为多态。  

+ 多态性依托于继承性。  

+ 多态主要针对的是对象具有的行为，而不是属性。  

+ 可以提高代码的灵活性，配合反射实现解耦。

### 编译时多态
方法重载 (Method Overload)  
是**行为多态**。  
发生在同一个类中，方法名一致而参数列表不同。和修饰符、返回值类型、异常无关。  

### 运行时多态
+ 向上造型
  + 是**对象多态**。  

  + 父类引用指向子类对象。  
    代码高亮标出。

    **Input**
    ``` java {11}
    class Super {
      // ...
    }

    class Sub extends Super {
      // ...
    }

    class App {
      public static void main(String args[]) {
        Super super = new Sub();  // 向上造型

        Sub sub = (Sub) new Super();  // 向下造型
      }
    }
    ```
    ::: danger 注意
    向下造型是不允许的，上面的例子会通过编译器检测，但运行后会抛出异常：  
    **Output**
    ```
    java.lang.ClassCastException: class Super cannot be cast to class Sub
    ```
    :::

  + 使用向上造型时，编译期**只检查两个类之间的关系**而**不检查具体用哪个类创建对象**  

  + 对象方法看父类，方法内容看子类。  

+ 方法覆盖 (Method Override)  
  + 又称方法重写，是**行为多态**。  

  + 发生在父子类中，双方拥有方法签名完全一致的非静态方法。  

  + 调用方法的时候，调用的是重写后的方法。  

  ::: warning 注意
    1. 子类重写的方法**权限修饰符需大于等于父类**。  

    2. 关于返回值类型  
       + 若**父类方法返回值类型是引用数据类型**，则子类重写的方法的返回值类型是父类方法返回值类型的子类或其本身。  

       + 若**父类方法返回值类型是基本数据类型**，则子类重写的方法返回值类型必须和父类方法相同。  
    
    3. 子类抛出的异常需为父类异常的子类。
  :::

  **Input**
  ``` java
  class A {
    /**
    * 方法 mA
    * @return void
    */
    public void mA() {
      // ...
    }
  }

  class B extends A {
    /**
    * 方法 mB
    * @return void
    */
    public void mB() {
      // ...
    }
  }

  /**
    * 方法 m
    * @return B
    */
  class C {
    public B m() {
      // ...
    }
  }

  class D extends C {
    /**
    * 方法 m
    * @return A
    */
    public A m() {
      // ...
    }
  }

  ...

  public static void main(String[] args) {
    // 用C类声明，用D类创建对象
    // 则对象c拥有返回值类型为B的方法m()
    C c = new D();

    // 用B类声明一个变量b，来接收方法的返回值
    // 方法调用的是D类中的m()
    // 由于D类中m()的返回值类型是A，故最终是用子类接收父类对象
    B b = c.m();

    // 对象b无法调用B类中的mB()
    // b.mB();
  }
  ```

## 权限修饰符
+ Java 提供了`public`, `protected`, `默认`, `private`四种访问修饰符。  
+ 通过访问修饰符来提高程序的安全性和可维护性。

修饰符|本类中|同包类中 (本包)|子类中|其他包中 (不同包中的所有类)
:-:|:-:|:-:|:-:|:-:
`public`|可以|可以|可以|可以
`protected`|可以|可以|可以|不可以
`默认`|可以|可以|同包可以|不可以
`private`|可以|不可以|不可以|不可以

## 非权限修饰符
### 静态
+ Java 中使用`static`关键字来标识静态。  

+ 可以使用静态来修饰变量、方法、内部类和代码块。  

#### 静态变量
+ 也称为**类变量**。  

+ 随着类的加载而被加载到方法区中，在其内部自动赋[默认值](./语法.html/#基本数据类型)。  

+ 静态变量优先于对象而存在，故静态变量可以不通过对象，直接通过类来调用（通过对象调用也是可以被理解的）。

+ 该类所产生的所有对象实际上保存该静态变量在静态区中的地址。  

+ 静态变量被该类的所有对象所共享。

![静态内存](/img/静态内存.png)  

**路标 ->** [Java 内存分区](./#内存分区)。

::: warning 注意
+ 静态变量**不能**定义在构造代码块中

+ 在构造代码块中**可以**对静态变量赋值

**Input**
``` java
class OneClass {
  static int iSta;

  {
    iSta = 10;
  }
}

```
:::

#### 静态方法
+ 也称为**类方法**。

+ 在类加载的时候加载到方法区中的静态区。只存储在静态区，方法被调用时在栈内存中执行。

+ 静态方法**先于对象而存在**，静态方法可通过类名或对象调用，不能直接使用本类中的非静态方法和非静态属性。

::: warning 注意
+ 静态方法中**不能**定义静态变量

+ 静态方法中**不能**直接调用类中的非静态方法

+ `main()`中**不能**使用`this`或`super`

+ 静态方法**不能**重写

+ 父子类中**可以**存在方法签名一致的静态方法
  父子类中存在方法签名完全一致的方法，两者或均被`static`修饰或都不被`static`修饰

+ 静态方法**可以**被继承

+ 类只加载一次，只在第一次使用时加载到方法去，加载之后不再移除
:::

#### 静态代码块
+ 类被第一次真正使用（创建对象/调用方法）时执行一次

+ 先父后子，先静后动

**Input**
``` java
class OneClass {
  static int i = 5; // Warning: Variable 'i' initializer '5' is redundan

  static {
    i = 7;
    i += 7;
  }
}

Class AnotherClass {
  static {
    i = 7;  // Warning: The value 7 assigned to 'i' is never used 
    i += 7; // Error: Illegal forward reference
  }

  static int i = 5;
}
```
+ 在`OneClass`中  
  首先编译`int i`，后续针对`i`的操作有效。  

+ 在`AnotherClass`中  
  编译到`i = 7;`时检查之前代码中是否定义过变量`i`，若上文不存在该变量则将其暂时标记为一个成员变量。  
  此时这个变量`i`不真实存在，后续对`i`的操作无效。  
  直到找到与标记名称`i`一致的成员变量时，才会将标记的`i`真正赋值。

### 抽象
`abstract`

### 最终
`final`

## 接口
`interface`

## 内部类