(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{528:function(v,_,t){"use strict";t.r(_);var l=t(18),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),t("p",[v._v("Redis 包含五个数据结构。分别是 String, List, Hash, Set 和 Sorted Set.  除了 String 以外，其他四种是集合类型，因为它们一个键对应一个集合的数据。")]),v._v(" "),t("h2",{attrs:{id:"全局哈希表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局哈希表"}},[v._v("#")]),v._v(" 全局哈希表")]),v._v(" "),t("p",[v._v("在 Redis 中，为了组织所有的键值对，它维护了两张全局哈希表。"),t("br"),v._v("\n哈希表是一个数组，每个元素称为一个哈希桶，哈希桶中不保存元素本身，而保存指向具体 entry 的指针。每一个 entry 由键值对构成，可以通过指针被访问到。"),t("br"),v._v("\n利用了这样的全局哈希表，就可以在 O(1) 的时间复杂度中找到键值对。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/redis/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg",alt:"全局哈希表"}})]),v._v(" "),t("h3",{attrs:{id:"哈希冲突"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哈希冲突"}},[v._v("#")]),v._v(" 哈希冲突")]),v._v(" "),t("p",[v._v("但是随着数据变多，因为哈希冲突和 rehash, 可能会带来操作阻塞。"),t("br"),v._v("\n当发生哈希冲突时，Redis 采用链式哈希的操作来解决冲突。同一个哈希桶用链表的形式保存多个元素。")]),v._v(" "),t("p",[v._v("当数据逐渐增加，链表会导致性能下降时，它会通过 rehash 启用第二张全局哈希表。rehash 过程为：")]),v._v(" "),t("ul",[t("li",[v._v("给第二张全局哈希表分配空间，大小是第一张的两倍")]),v._v(" "),t("li",[v._v("将第一张全局哈希表中的数据重新映射到第二张中")]),v._v(" "),t("li",[v._v("释放第一张全局哈希表的空间")])]),v._v(" "),t("p",[v._v("为了避免第二步中数据映射可能带来的巨大开销，Redis 的 rehash 过程是渐进式的。即在映射过程中，Redis 仍然正常处理客户端请求。每处理一个请求，就通过键找到对应的第一张全局哈希表中的哈希桶位置，并将其所有 entry 都拷贝到第二张全局哈希表中。"),t("br"),v._v("\n通过这样的操作分摊了一次高开销的操作，并且保证了数据的快速访问。")]),v._v(" "),t("h2",{attrs:{id:"内置数据结构与底层实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置数据结构与底层实现"}},[v._v("#")]),v._v(" 内置数据结构与底层实现")]),v._v(" "),t("h3",{attrs:{id:"内置数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置数据结构"}},[v._v("#")]),v._v(" 内置数据结构")]),v._v(" "),t("ul",[t("li",[v._v("String\n"),t("ul",[t("li",[v._v("底层实现：简单动态字符串")])])]),v._v(" "),t("li",[v._v("List\n"),t("ul",[t("li",[v._v("底层实现：压缩列表；双向链表")])])]),v._v(" "),t("li",[v._v("Hash\n"),t("ul",[t("li",[v._v("底层实现：压缩列表；哈希表")])])]),v._v(" "),t("li",[v._v("Set\n"),t("ul",[t("li",[v._v("底层实现：整数数组；哈希表")])])]),v._v(" "),t("li",[v._v("Sorted Set (ZSet)\n"),t("ul",[t("li",[v._v("底层实现：压缩列表；跳表")])])])]),v._v(" "),t("h3",{attrs:{id:"底层实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#底层实现"}},[v._v("#")]),v._v(" 底层实现")]),v._v(" "),t("ul",[t("li",[v._v("压缩列表\n"),t("ul",[t("li",[v._v("类似数组，每一个位置保存一个数据。")]),v._v(" "),t("li",[v._v("表头有三个字段：zlbytes, 列表长度； zltail, 列表尾偏移量；zllen, 列表 entry 个数.")]),v._v(" "),t("li",[v._v("表尾有一个字段：zlend, 列表结束。")]),v._v(" "),t("li",[v._v("当查找第一个和最后一个元素时，利用表头三个字段直接定位，时间复杂度 O(1)")]),v._v(" "),t("li",[v._v("当查找其他元素时，时间复杂度 O(n)")])])]),v._v(" "),t("li",[v._v("跳表\n"),t("ul",[t("li",[v._v("在链表的基础上，增加了多级索引。通过索引位置进行跳转来快速定位。")]),v._v(" "),t("li",[v._v("时间复杂度为 O(logN)")])])])]),v._v(" "),t("h2",{attrs:{id:"操作的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作的时间复杂度"}},[v._v("#")]),v._v(" 操作的时间复杂度")]),v._v(" "),t("ul",[t("li",[v._v("单元素操作"),t("br"),v._v("\n对单个元素的操作\n"),t("ul",[t("li",[v._v("O(1)\n"),t("ul",[t("li",[v._v("Hash: HGET, HSET, HDEL")]),v._v(" "),t("li",[v._v("Set: SADD, SREM, SRANDMEMBER")])])])])]),v._v(" "),t("li",[v._v("范围操作"),t("br"),v._v("\n对集合遍历操作，时间复杂度为 O(n). 但在 Redis 2.8 提供的 SCAN 操作下采用渐进式遍历，可以避免阻塞。\n"),t("ul",[t("li",[v._v("O(n)\n"),t("ul",[t("li",[v._v("Hash: HGETALL")]),v._v(" "),t("li",[v._v("Set: SMEMBERS")]),v._v(" "),t("li",[v._v("List: LRANGE")]),v._v(" "),t("li",[v._v("Sorted Set: ZRANGE")])])])])]),v._v(" "),t("li",[v._v("统计操作\n"),t("ul",[t("li",[v._v("统计集合中元素个数，时间复杂度为 O(1). 例如：LLEN, SCARD")])])]),v._v(" "),t("li",[v._v("例外情况\n"),t("ul",[t("li",[v._v("利用压缩列表和双向列表的头尾偏移量的操作时间复杂度都为 O(1). 例如：LPOP, RPOP, LPUSH, RPUSH")])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);