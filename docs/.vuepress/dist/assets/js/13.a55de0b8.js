(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{217:function(v,_,t){"use strict";t.r(_);var a=t(2),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"api-工具类库-package-java-util"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-工具类库-package-java-util"}},[v._v("#")]),v._v(" API-工具类库 (Package "),t("code",[v._v("java.util")]),v._v(")")]),v._v(" "),t("h2",{attrs:{id:"日期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日期"}},[v._v("#")]),v._v(" 日期")]),v._v(" "),t("h3",{attrs:{id:"date类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#date类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Date")]),v._v("类")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public class Date")])]),v._v(" "),t("ul",[t("li",[v._v("使用"),t("code",[v._v("Date")]),v._v("类对象来表示一个日期。默认创建的对象会获取系统当前时间。")])]),v._v(" "),t("p",[t("strong",[v._v("重要方法")])]),v._v(" "),t("p",[t("strong",[v._v("格式化日期显示")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("将字符串转化为日期对象"),t("br"),v._v("\n使用"),t("code",[v._v("SimpleDateFormat")]),v._v("类向上造型，调用其"),t("code",[v._v("Date parse(String source)")]),v._v("来转换。"),t("br"),v._v(" "),t("strong",[v._v("Input")])]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Date")]),v._v(" date "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("SimpleDateFormat")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"yyyy-MM-dd HH:mm:ss"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("parse")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"2000-02-01 12:42:15"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])]),v._v(" "),t("li",[t("p",[v._v("将日期对象转换为字符串\n使用"),t("code",[v._v("SimpleDateFormat")]),v._v("类向上造型，调用其"),t("code",[v._v("StringBuffer format(Date date)")]),v._v("来转换。"),t("br"),v._v(" "),t("strong",[v._v("Input")])]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("String")]),v._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("SimpleDateFormat")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"yyyy年MM月dd日"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("format")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("date"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])])]),v._v(" "),t("h3",{attrs:{id:"calendar类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#calendar类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Calendar")]),v._v("类")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public abstract class Calendar")])]),v._v(" "),t("ul",[t("li",[v._v("使用静态方法"),t("code",[v._v("static Calendar getInstance()")]),v._v("来获取一个"),t("code",[v._v("Calendar")]),v._v("类实例。")])]),v._v(" "),t("h2",{attrs:{id:"集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[v._v("#")]),v._v(" 集合")]),v._v(" "),t("h3",{attrs:{id:"collcetion接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collcetion接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("Collcetion")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public interface Collection<E>")])]),v._v(" "),t("ul",[t("li",[v._v("是集合类的顶级接口")]),v._v(" "),t("li",[v._v("其中"),t("code",[v._v("<E>")]),v._v("是泛型，代表该集合只能存储"),t("code",[v._v("E")]),v._v("类的数据作为元素(element)，且必须是引用数据类型。"),t("br"),v._v("\n如："),t("code",[v._v("Collection<String>")]),v._v("限定集合中只能存储"),t("code",[v._v("String")]),v._v("类的数据。")])]),v._v(" "),t("h3",{attrs:{id:"list接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("List")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public interface List<E>")])]),v._v(" "),t("ul",[t("li",[v._v("是一种有序的"),t("code",[v._v("Collection")])]),v._v(" "),t("li",[v._v("元素有序（存入顺序），可重复")]),v._v(" "),t("li",[v._v("元素存在下标，可通过下标操作对应的元素")])]),v._v(" "),t("p",[t("strong",[v._v("重要实现类")]),t("br"),v._v(" "),t("code",[v._v("ArrayList")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("默认初始容量为10；扩容时，在上一次的基础上扩容一半容量")]),v._v(" "),t("li",[v._v("线程不安全的集合")]),v._v(" "),t("li",[v._v("内存空间连续")]),v._v(" "),t("li",[v._v("增删元素比较慢")])]),v._v(" "),t("p",[t("code",[v._v("LinkedList")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("基于链表实现，增删快，查询慢")]),v._v(" "),t("li",[v._v("线程不安全的集合\n"),t("img",{attrs:{src:"/img/LinkedList.png",alt:"LinkedList"}})])]),v._v(" "),t("p",[t("code",[v._v("Vector")]),v._v("类")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("Java 中最早的集合，初始容量是10")])]),v._v(" "),t("li",[t("p",[v._v("内存空间连续")])]),v._v(" "),t("li",[t("p",[v._v("每次扩容1倍")])]),v._v(" "),t("li",[t("p",[v._v("线程安全")])]),v._v(" "),t("li",[t("p",[v._v("使用方法"),t("code",[v._v("elements()")]),v._v("来返回枚举")]),v._v(" "),t("p",[t("strong",[v._v("重要派生类")]),t("br"),v._v(" "),t("code",[v._v("Stack")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("遵循先进后出的原则")]),v._v(" "),t("li",[v._v("最先放入的元素称为栈底元素")]),v._v(" "),t("li",[v._v("最后放入的元素称为栈顶元素")]),v._v(" "),t("li",[v._v("放入——入栈/压栈")]),v._v(" "),t("li",[v._v("拿出——出栈/弹栈")])])])]),v._v(" "),t("h3",{attrs:{id:"queue接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#queue接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("Queue")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public interface Queue<E>")])]),v._v(" "),t("ul",[t("li",[v._v("遵循先进先出的原则。")]),v._v(" "),t("li",[v._v("是一种特殊的"),t("code",[v._v("Collection")])]),v._v(" "),t("li",[v._v("其线性实现有"),t("code",[v._v("ListQueue")])])]),v._v(" "),t("h3",{attrs:{id:"set接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("Set")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public interface Set<E>")])]),v._v(" "),t("ul",[t("li",[v._v("是散列的"),t("code",[v._v("Collection")])]),v._v(" "),t("li",[v._v("元素不可重复")]),v._v(" "),t("li",[v._v("不保证存入顺序")]),v._v(" "),t("li",[v._v("基于哈希码存放")]),v._v(" "),t("li",[v._v("若添加相同元素则抛弃"),t("br"),v._v("\n使用equals()比较时，比较实际元素")])]),v._v(" "),t("p",[t("strong",[v._v("重要实现类")]),t("br"),v._v(" "),t("code",[v._v("HashSet")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("默认初始容量为 16, 加载因子为 0.75F"),t("br"),v._v("\nloadFactor 加载因子/装载因子，"),t("code",[v._v("float")]),v._v("类型")]),v._v(" "),t("li",[v._v("每次扩容一倍")]),v._v(" "),t("li",[v._v("是线程不安全的集合")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("值得注意的是")]),v._v(" "),t("p",[v._v("在数据结构知识中，栈和队列是一种有着特殊规则的线性表。而在 Java 语言中各个集合类之间的继承、实现关系并不完全符合传统数据结构知识。")])]),v._v(" "),t("h2",{attrs:{id:"并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发"}},[v._v("#")]),v._v(" 并发")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util.concurrent")]),v._v(" "),t("h3",{attrs:{id:"blockingqueue接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("BlockingQueue")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("code",[v._v("public interface BlockingQueue<E>")])]),v._v(" "),t("p",[t("strong",[v._v("重要实现类")]),t("br"),v._v(" "),t("code",[v._v("ArrayBlockingQueue")]),v._v("类"),t("br"),v._v("\n是基于数组且有界的阻塞队列。")]),v._v(" "),t("p",[v._v("​\t​\t"),t("strong",[v._v("重要方法")])]),v._v(" "),t("ol",[t("li",[t("p",[t("code",[v._v("add(object)")])]),v._v(" "),t("ul",[t("li",[v._v("非阻塞")]),v._v(" "),t("li",[v._v("底层调用"),t("code",[v._v("offer()")])]),v._v(" "),t("li",[v._v("添加溢出抛异常"),t("code",[v._v("IllegalStateException: Queue full")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("offer(object)")])]),v._v(" "),t("ul",[t("li",[v._v("非阻塞")]),v._v(" "),t("li",[v._v("添加溢出返回"),t("code",[v._v("false")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("offer(object, timeout, TimeUnit.xxx)")])]),v._v(" "),t("ul",[t("li",[t("code",[v._v("timeout")]),v._v("期间内一直尝试添加，若超时未添加成功则返回"),t("code",[v._v("false")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("put(object)")])]),v._v(" "),t("ul",[t("li",[v._v("阻塞")])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("remove(object)")])]),v._v(" "),t("ul",[t("li",[v._v("非阻塞")]),v._v(" "),t("li",[v._v("队空，不报错")])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("remove()")])]),v._v(" "),t("ul",[t("li",[v._v("非阻塞")]),v._v(" "),t("li",[v._v("队空则抛异常"),t("code",[v._v("NoSuchElementException")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("poll()")])]),v._v(" "),t("ul",[t("li",[v._v("非阻塞")]),v._v(" "),t("li",[v._v("队空返回"),t("code",[v._v("null")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("poll(timeout, TimeUnit.xxx)")])]),v._v(" "),t("ul",[t("li",[t("code",[v._v("timeout")]),v._v("期间内一直尝试移除队首，若超时未添加成功则返回"),t("code",[v._v("null")])])])]),v._v(" "),t("li",[t("p",[t("code",[v._v("take(object)")])]),v._v(" "),t("ul",[t("li",[v._v("阻塞")])])])]),v._v(" "),t("h3",{attrs:{id:"blockingdeque接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockingdeque接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("BlockingDeque")]),v._v("接口")]),v._v(" "),t("h3",{attrs:{id:"concurrentmap接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrentmap接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("ConcurrentMap")]),v._v("接口")]),v._v(" "),t("h3",{attrs:{id:"countdownlatch类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch类"}},[v._v("#")]),v._v(" "),t("code",[v._v("CountDownLatch")]),v._v("类")]),v._v(" "),t("h3",{attrs:{id:"cyclicbarrier类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier类"}},[v._v("#")]),v._v(" "),t("code",[v._v("CyclicBarrier")]),v._v("类")]),v._v(" "),t("h3",{attrs:{id:"exchanger类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exchanger类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Exchanger")]),v._v("类")]),v._v(" "),t("h3",{attrs:{id:"semaphore类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#semaphore类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Semaphore")]),v._v("类")]),v._v(" "),t("h3",{attrs:{id:"executorservice接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#executorservice接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("ExecutorService")]),v._v("接口")]),v._v(" "),t("h3",{attrs:{id:"锁与原子操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁与原子操作"}},[v._v("#")]),v._v(" 锁与原子操作")]),v._v(" "),t("h2",{attrs:{id:"iterator接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iterator接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("Iterator")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public interface Iterator<E>")])]),v._v(" "),t("Badge",{attrs:{text:"Java SE 5.0+"}}),v._v(" "),t("ul",[t("li",[v._v("通过指针挪动遍历集合")]),v._v(" "),t("li",[v._v("遍历过程中不允许增删原集合")]),v._v(" "),t("li",[v._v("若一个对象允许使用 foreach 遍历，该类必须实现"),t("code",[v._v("Iterable")]),v._v("接口")])]),v._v(" "),t("h2",{attrs:{id:"collections类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collections类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Collections")]),v._v("类")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public class Collections")])]),v._v(" "),t("p",[v._v("操作集合的工具类")]),v._v(" "),t("p",[t("strong",[v._v("重要方法")]),t("br"),v._v(" "),t("code",[v._v("compare(T o1, T o2)")])]),v._v(" "),t("ul",[t("li",[v._v("返回正负值来确定大小")]),v._v(" "),t("li",[v._v("若为正则第一个数排到第二个数之后；反之排到其前")]),v._v(" "),t("li",[v._v("若没有指定排序规则， 必须实现"),t("code",[v._v("Comparable")]),v._v("接口，比较规则写在"),t("code",[v._v("compareTo()")]),v._v("中")])]),v._v(" "),t("h2",{attrs:{id:"map接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map接口"}},[v._v("#")]),v._v(" "),t("code",[v._v("Map")]),v._v("接口")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("Interface Map<K,​V>")])]),v._v(" "),t("ul",[t("li",[v._v("以键-值对形式存在的数据结构，其中键是唯一的")]),v._v(" "),t("li",[v._v("遍历"),t("code",[v._v("Map")]),v._v("的方法\n"),t("ul",[t("li",[v._v("获取所有键，通过键来获取值")]),v._v(" "),t("li",[v._v("获取键值对组成的集合")])])])]),v._v(" "),t("p",[t("strong",[v._v("重要实现类")]),t("br"),v._v(" "),t("code",[v._v("HashMap")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("默认初始容量是 16, 加载因子为 0.75F")]),v._v(" "),t("li",[v._v("每次扩容一倍")]),v._v(" "),t("li",[v._v("允许键或值为"),t("code",[v._v("null")])]),v._v(" "),t("li",[v._v("异步式线程不安全的映射，不对映射做安全限制")])]),v._v(" "),t("p",[t("code",[v._v("HashTable")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("默认初始容量为 11, 加载因子为 0.75F")]),v._v(" "),t("li",[v._v("不允许键或值为"),t("code",[v._v("null")])]),v._v(" "),t("li",[v._v("同步式线程安全的映射\n"),t("ul",[t("li",[v._v("对外公开的涉及到键值对的操作方法都是同步方法")]),v._v(" "),t("li",[v._v("锁对象是"),t("code",[v._v("this")]),v._v("，"),t("code",[v._v("HashTable")]),v._v("以本身对象作为锁对象")])])])]),v._v(" "),t("p",[t("code",[v._v("ConcurrentHashMap")]),v._v("类")]),v._v(" "),t("ul",[t("li",[v._v("异步式线程安全的映射")]),v._v(" "),t("li",[v._v("引入分段锁（分桶锁）\n详情见"),t("a",{attrs:{href:"#concurrentmap%E6%8E%A5%E5%8F%A3"}},[v._v("ConcurrentMap")])])]),v._v(" "),t("h2",{attrs:{id:"properties类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#properties类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Properties")]),v._v("类")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public class Properties")])]),v._v(" "),t("ul",[t("li",[v._v("是一个可以持久化的映射")]),v._v(" "),t("li",[v._v("键和值默认为"),t("code",[v._v("String")]),v._v("类型")]),v._v(" "),t("li",[t("code",[v._v("Properties")]),v._v("对象必须存储到"),t("code",[v._v("properties")]),v._v("文件中")]),v._v(" "),t("li",[t("code",[v._v("properties")]),v._v("文件中不能存储中文，会变成对应的编码")])]),v._v(" "),t("p",[t("strong",[v._v("重要方法")]),t("br"),v._v(" "),t("code",[v._v('setProperty("键","值")')]),t("br"),v._v(" "),t("code",[v._v("store(输出流, comments)")]),t("br"),v._v(" "),t("code",[v._v("load(输入流)")])]),v._v(" "),t("h2",{attrs:{id:"scanner类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scanner类"}},[v._v("#")]),v._v(" "),t("code",[v._v("Scanner")]),v._v("类")]),v._v(" "),t("p",[t("strong",[v._v("基本信息")]),t("br"),v._v(" "),t("strong",[v._v("Package")]),v._v(" java.util"),t("br"),v._v(" "),t("code",[v._v("public final class Scanner")])]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("除了"),t("code",[v._v("nextLine()")]),v._v("，其余都是以空格为结束符")])])],1)}),[],!1,null,null,null);_.default=e.exports}}]);