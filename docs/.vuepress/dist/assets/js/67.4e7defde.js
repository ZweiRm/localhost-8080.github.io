(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{544:function(v,_,a){"use strict";a.r(_);var t=a(19),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[v._v("#")]),v._v(" 持久化")]),v._v(" "),a("h2",{attrs:{id:"aof日志系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof日志系统"}},[v._v("#")]),v._v(" AOF日志系统")]),v._v(" "),a("p",[v._v("AOF 日志是后写日志，Redis 先执行命令，将数据写入内存后才记录日志。")]),v._v(" "),a("h3",{attrs:{id:"写回策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写回策略"}},[v._v("#")]),v._v(" 写回策略")]),v._v(" "),a("p",[v._v("对于 AOF 的写回策略，其配置项 appendfsync 中给出了三种可选项：")]),v._v(" "),a("ul",[a("li",[v._v("Always\n"),a("ul",[a("li",[v._v("同步写回。每个写命令执行完之后立刻同步地将日志写回磁盘。")]),v._v(" "),a("li",[v._v("优点：可靠性高，数据基本不会丢失")]),v._v(" "),a("li",[v._v("缺点：性能影响较大")])])]),v._v(" "),a("li",[v._v("Everysec\n"),a("ul",[a("li",[v._v("每秒写回。每个写命令执行完毕后，只把日志写入到 AOF 内存缓冲区，之后每隔一秒把缓冲区的内容写入磁盘。")]),v._v(" "),a("li",[v._v("优点：性能适中")]),v._v(" "),a("li",[v._v("缺点：宕机时丢失一秒内的数据")])])]),v._v(" "),a("li",[v._v("No\n"),a("ul",[a("li",[v._v("操作系统控制写回。每隔写命令执行完毕后，只把日志写入到 AOF 内存缓冲区，之后由操作系统决定何时将缓存写回到磁盘。")]),v._v(" "),a("li",[v._v("性能好")]),v._v(" "),a("li",[v._v("宕机时丢失数据较多")])])])]),v._v(" "),a("p",[v._v("具体根据对系统的高性能和高可靠性要求来选择写回策略。")]),v._v(" "),a("h3",{attrs:{id:"重写机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重写机制"}},[v._v("#")]),v._v(" 重写机制")]),v._v(" "),a("p",[v._v("当随着系统运行，命令增多时，AOF 文件也会逐渐变大。Redis 会在重写时根据数据库的状况新建一个 AOF 文件，称为重写机制。即读取数据库内所有键值对，然后对每一条记录用一个命令记录下来。以这样的方法可以合并旧日志文件中某些命令，在重写时只保存一条。")]),v._v(" "),a("p",[v._v("重写过程为一个拷贝，两处日志。它不由主线程写回，而是由后台线程 bgrewriteaof 完成。"),a("br"),v._v("\n当发生重写时，主线程将主线程内存拷贝一份给 bgrewriteaof 子线程中，之后子线程逐一将数据写成操作记入重写日志。"),a("br"),v._v("\n第一处日志指当前正在运行的 AOF 日志。在重写过程中，主线程不会阻塞，这时仍然可能会有新的操作进行。Redis 会将操作继续写入旧 AOF 日志中。"),a("br"),v._v("\n第二处日志是重写的新 AOF 日志。通过两处日志，在重写完成后继续将旧 AOF 中的新操作写入新 AOF 中来保证数据库最新状态，之后用新 AOF 代替旧 AOF.")]),v._v(" "),a("h2",{attrs:{id:"rdb快照系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb快照系统"}},[v._v("#")]),v._v(" RDB快照系统")]),v._v(" "),a("p",[v._v("Redis Database (RDB) 记录某一时刻的数据，它记录内存中的所有数据。"),a("br"),v._v("\nRDB 文件生成使用命令 "),a("code",[v._v("save")]),v._v(" 和 "),a("code",[v._v("bgsave")]),v._v(" 两种。其中 "),a("code",[v._v("save")]),v._v(" 在主线程中执行，会阻塞主线程；而 bgsave` 创建一个子进程专门写入 RDB 文件，是默认配置。"),a("br"),v._v("\n为了避免创建 RDB 文件时不可以正常处理写操作的问题，Redis 采用了 Copy on write 技术。快照子线程共享主线程的内存数据。当主线程为读操作时不受影响。当主线程对数据修改时，被修改数据会复制一份，子线程将副本数据写入 RDB 文件。")]),v._v(" "),a("h3",{attrs:{id:"aof-与-rdb-联合使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-与-rdb-联合使用"}},[v._v("#")]),v._v(" AOF 与 RDB 联合使用")]),v._v(" "),a("p",[v._v("为了避免连续快照或者增量快照带来的高消耗，Redis 采用了混合使用 AOF 和 RDB 的方法来保证数据持久化的正确性。即内存快照以一定频率执行，每两次之间使用 AOF 记录所有操作。"),a("br"),v._v("\n通过这样的方法，避免了 RDB 快照频繁对主线程的影响，也避免了 AOF 重写过大的开销。")]),v._v(" "),a("p",[v._v("启发规则：")]),v._v(" "),a("ul",[a("li",[v._v("当要保证数据不丢失时，联用 RDB 和 AOF")]),v._v(" "),a("li",[v._v("允许分钟级别的数据丢失时，可只启用 RDB")]),v._v(" "),a("li",[v._v("若只能使用 AOF，则优先选择 everysec 配置")])])])}),[],!1,null,null,null);_.default=e.exports}}]);