(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{476:function(a,r,t){"use strict";t.r(r);var v=t(20),s=Object(v.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java-虚拟机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机"}},[a._v("#")]),a._v(" Java 虚拟机")]),a._v(" "),t("p",[a._v("Java 中使用范围最广的虚拟机就是 HotSpot 虚拟机，这里介绍相关的知识。")]),a._v(" "),t("h2",{attrs:{id:"内存分区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分区"}},[a._v("#")]),a._v(" 内存分区")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png",alt:"内存分区"}})]),a._v(" "),t("ul",[t("li",[t("p",[a._v("程序计数器"),t("br"),a._v("\n是寄存器，负责程序计数和任务调度。"),t("br"),a._v("\n虚拟机中的字节码解释器通过改变程序计数器来依次读取指令，以此实现代码流程控制。"),t("br"),a._v("\n在多线程情况下，程序计数器记录当前线程执行位置，当线程切换时可以获得运行位置信息。"),t("br"),a._v("\n生命周期随着线程的创建而创建，随着线程的结束而死亡。")])]),a._v(" "),t("li",[t("p",[a._v("本地方法栈"),t("br"),a._v("\n描述本地（原生）方法执行的内存模型。"),t("br"),a._v("\n本地方法被执行的时候，在本地方法栈会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。"),t("br"),a._v("\n可能会出现 StackOverFlowError 和 OutOfMemoryError.")])]),a._v(" "),t("li",[t("p",[a._v("栈内存（虚拟机栈）"),t("br"),a._v("\n描述 Java 方法（字节码）执行的内存模型，每次方法调用的数据都是通过栈传递的。"),t("br"),a._v("\n由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。"),t("br"),a._v("\n其中最重要的是局部变量表，它主要存放编译器可知的各种数据类型和对象引用。"),t("br"),a._v("\n每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束或抛出异常后，都会有一个栈帧被弹出。"),t("br"),a._v("\nStackOverFlowError：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。"),t("br"),a._v("\nOutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 错误。")])]),a._v(" "),t("li",[t("p",[a._v("堆内存"),t("br"),a._v("\n存储对象（对象生命周期结束后被 "),t("code",[a._v("GC")]),a._v(" 回收，堆也被成为 GC 堆），对象实例和数组会被分配在这里。"),t("br"),a._v("\n堆内存分为：新生代，老年代和永久代。其中新生代包括伊甸园区（Eden）和两个幸存区（Survivor, S0, S1）"),t("br"),a._v("\n可能会出现 OutOfMemoryError, 具体还分为 GC Overhead Limit Exceeded, Java heap space 等情形。")])]),a._v(" "),t("li",[t("p",[a._v("方法区"),t("br"),a._v("\n存储类的信息（已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）"),t("br"),a._v("\n虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。"),t("br"),a._v("\n方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口。而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。"),t("br"),a._v("\n方法区溢出会报 "),t("code",[a._v("OutOfMemoryError")]),a._v(" 错误"),t("br"),a._v("\n方法区中垃圾回收行为很少出现，可以用以下命令对该分区大小进行调节：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PermSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("N")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//方法区 (永久代) 初始大小")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MaxPermSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("N")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError")]),a._v("\n")])])]),t("p",[a._v("其中：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("静态区"),t("br"),a._v("\n存储静态属性和静态方法"),t("br"),a._v("\n静态属性存储在此区后自动赋默认值")])]),a._v(" "),t("li",[t("p",[a._v("静态常量池"),t("br"),a._v("\n存储类成员属性和成员方法信息")])]),a._v(" "),t("li",[t("p",[a._v("运行时常量池"),t("br"),a._v("\n存储计算机常量和被 "),t("code",[a._v("final")]),a._v(" 修饰的常量副本\n逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。"),t("Badge",{attrs:{type:"error",text:"Java 7.0-"}}),t("br"),a._v("\n运行时常量池剩下的东西还在方法区（永久代）中，但字符串常量池被从方法区拿到了堆中。"),t("Badge",{attrs:{type:"warning",text:"Java 7.0"}}),t("br"),a._v("\n移除了永久代而用元空间取代, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间。"),t("Badge",{attrs:{text:"Java 8.0+"}})],1)])])]),a._v(" "),t("li",[t("p",[a._v("直接内存"),t("br"),a._v("\n直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。"),t("br"),a._v("\n可能导致 OutOfMemoryError."),t("br"),a._v("\nJDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。"),t("Badge",{attrs:{text:"Java 1.4+"}})],1)])]),a._v(" "),t("p",[a._v("其中堆内存、方法区与直接内存是所有线程共享的，而栈内存（虚拟机栈）、本地方法栈与程序计数器是每个线程独有的。")]),a._v(" "),t("p",[a._v("在Java 8 后，虚拟机对内存分配有了更新"),t("Badge",{attrs:{text:"Java 8.0+"}}),a._v("："),t("br"),a._v(" "),t("img",{attrs:{src:"/img/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1_8.png",alt:"内存模型 1.8"}}),a._v("\n在 Java 8 之后，通过合并 HotSpot 与 JRockit 虚拟机，永久代被元空间代替，而元空间使用直接内存。"),t("br"),a._v("\n使用命令来调节元空间大小：")],1),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MetaspaceSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("N")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//设置 Metaspace 的初始（和最小大小）")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MaxMetaspaceSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("N")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//设置 Metaspace 的最大大小")]),a._v("\n")])])]),t("p",[a._v("MetaspaceSize 默认值为 unlimited，意味着它只受系统内存的限制；MetaspaceSize 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。"),t("br"),a._v("\n元空间里面存放的是类的元数据，通过使用元空间而不是永久代来增加可加载类的数量。（仅受机器实际可用空间限制）")]),a._v(" "),t("h2",{attrs:{id:"垃圾分代回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾分代回收机制"}},[a._v("#")]),a._v(" 垃圾分代回收机制")]),a._v(" "),t("p",[a._v("对象在堆内存中存储。当对象在使用完成后，会在某个不定的时刻被垃圾回收器"),t("code",[a._v("GC")]),a._v("解析。"),t("br"),a._v("\n值得注意的是："),t("strong",[a._v("垃圾回收过程无法手动控制")]),a._v("。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("堆内存分为"),t("strong",[a._v("新生代区")]),a._v("和"),t("strong",[a._v("老年代区")]),a._v("。")])]),a._v(" "),t("li",[t("p",[a._v("新生代区分为"),t("strong",[a._v("伊甸园区")]),a._v("和"),t("strong",[a._v("幸存区")]),a._v("。")])]),a._v(" "),t("li",[t("p",[a._v("一个新创建的对象会被生成在伊甸园区，若在伊甸园区的对象经过一次回收过程仍然存活，则被移动到幸存区。")])]),a._v(" "),t("li",[t("p",[a._v("幸存区的回收扫描频率略低于伊甸园区。在幸存区经过多次扫描，若对象仍然存活，则被移动到老年代区。")])]),a._v(" "),t("li",[t("p",[a._v("老年代区的回收扫描频率会远远低于新生代区。")])]),a._v(" "),t("li",[t("p",[a._v("当老年代区中的对象被回收时，会导致程序卡顿甚至崩溃。")])]),a._v(" "),t("li",[t("p",[a._v("发生在新生代区的垃圾回收称为"),t("strong",[a._v("初代回收 (Minor GC)")]),a._v(".")])]),a._v(" "),t("li",[t("p",[a._v("发生在老年代区的垃圾回收称为"),t("strong",[a._v("完全回收 (Full GC)")]),a._v(".")])])])])}),[],!1,null,null,null);r.default=s.exports}}]);