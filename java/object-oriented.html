<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象 | 本地煮鸡:8080</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="一个博客, 大概会记录一些技术笔记">
    <meta property="article:modified_time" content="null">
    <meta property="og:site_name" content="本地煮鸡:8080">
    <meta property="og:title" content="面向对象">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/java/object-oriented.html">
    <meta name="twitter:title" content="面向对象">
    <meta name="twitter:url" content="/java/object-oriented.html">
    
    <link rel="preload" href="/assets/css/0.styles.ecc20c62.css" as="style"><link rel="preload" href="/assets/js/app.ed89cf52.js" as="script"><link rel="preload" href="/assets/js/3.f83a99be.js" as="script"><link rel="preload" href="/assets/js/39.ae81f180.js" as="script"><link rel="preload" href="/assets/js/6.99f29953.js" as="script"><link rel="preload" href="/assets/js/5.612dc22d.js" as="script"><link rel="prefetch" href="/assets/js/10.a5161dde.js"><link rel="prefetch" href="/assets/js/11.d9d749fe.js"><link rel="prefetch" href="/assets/js/12.e9fd7213.js"><link rel="prefetch" href="/assets/js/13.752bd570.js"><link rel="prefetch" href="/assets/js/14.74353e5c.js"><link rel="prefetch" href="/assets/js/15.6d78bf84.js"><link rel="prefetch" href="/assets/js/16.5f0818f2.js"><link rel="prefetch" href="/assets/js/17.befe7212.js"><link rel="prefetch" href="/assets/js/18.d84b5664.js"><link rel="prefetch" href="/assets/js/19.5e271eff.js"><link rel="prefetch" href="/assets/js/20.5b385699.js"><link rel="prefetch" href="/assets/js/21.abb57c4d.js"><link rel="prefetch" href="/assets/js/22.ca27b41c.js"><link rel="prefetch" href="/assets/js/23.7cc6f7fb.js"><link rel="prefetch" href="/assets/js/24.df6e70d5.js"><link rel="prefetch" href="/assets/js/25.e47db156.js"><link rel="prefetch" href="/assets/js/26.ea53f69d.js"><link rel="prefetch" href="/assets/js/27.e74e39a4.js"><link rel="prefetch" href="/assets/js/28.37f33672.js"><link rel="prefetch" href="/assets/js/29.13565ef4.js"><link rel="prefetch" href="/assets/js/30.c5a8587d.js"><link rel="prefetch" href="/assets/js/31.3e83ac1d.js"><link rel="prefetch" href="/assets/js/32.4b242ec9.js"><link rel="prefetch" href="/assets/js/33.5dae66c1.js"><link rel="prefetch" href="/assets/js/34.69c54f82.js"><link rel="prefetch" href="/assets/js/35.451420fc.js"><link rel="prefetch" href="/assets/js/36.38908e43.js"><link rel="prefetch" href="/assets/js/37.dcae9c46.js"><link rel="prefetch" href="/assets/js/38.87c13e35.js"><link rel="prefetch" href="/assets/js/4.e99d6e4e.js"><link rel="prefetch" href="/assets/js/40.36c4f11d.js"><link rel="prefetch" href="/assets/js/41.fdb38cd8.js"><link rel="prefetch" href="/assets/js/42.6314fab3.js"><link rel="prefetch" href="/assets/js/43.c6ac6c24.js"><link rel="prefetch" href="/assets/js/44.b5213dfa.js"><link rel="prefetch" href="/assets/js/45.db704e14.js"><link rel="prefetch" href="/assets/js/46.874d23c4.js"><link rel="prefetch" href="/assets/js/47.713dd6ed.js"><link rel="prefetch" href="/assets/js/48.9916d458.js"><link rel="prefetch" href="/assets/js/49.fa622c3c.js"><link rel="prefetch" href="/assets/js/50.a6923b34.js"><link rel="prefetch" href="/assets/js/51.6c6078d0.js"><link rel="prefetch" href="/assets/js/52.9de35595.js"><link rel="prefetch" href="/assets/js/53.82472cc3.js"><link rel="prefetch" href="/assets/js/54.47d098cf.js"><link rel="prefetch" href="/assets/js/55.c6569a40.js"><link rel="prefetch" href="/assets/js/56.b1de2e32.js"><link rel="prefetch" href="/assets/js/57.562e9d38.js"><link rel="prefetch" href="/assets/js/58.09c681fc.js"><link rel="prefetch" href="/assets/js/59.52cdc848.js"><link rel="prefetch" href="/assets/js/60.655b586f.js"><link rel="prefetch" href="/assets/js/61.fb26c5b2.js"><link rel="prefetch" href="/assets/js/62.4df0d4f3.js"><link rel="prefetch" href="/assets/js/63.81161c74.js"><link rel="prefetch" href="/assets/js/64.e0b4dd35.js"><link rel="prefetch" href="/assets/js/65.2c27de1a.js"><link rel="prefetch" href="/assets/js/66.8b69ae23.js"><link rel="prefetch" href="/assets/js/67.98709f71.js"><link rel="prefetch" href="/assets/js/68.8d32d42c.js"><link rel="prefetch" href="/assets/js/69.70eedef4.js"><link rel="prefetch" href="/assets/js/7.fc3990b3.js"><link rel="prefetch" href="/assets/js/70.5c51f62e.js"><link rel="prefetch" href="/assets/js/8.cd912e3b.js"><link rel="prefetch" href="/assets/js/9.b00a2bb6.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.899652fe.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ecc20c62.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">本地煮鸡:8080</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/" class="nav-link router-link-active">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/hello-world/" class="nav-link">
  杂谈
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="施工中笔记" class="dropdown-title"><span class="title">施工中笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="施工中笔记" class="mobile-dropdown-title"><span class="title">施工中笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          编程语言
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/kotlin/" class="nav-link">
  Kotlin
</a></li><li class="dropdown-subitem"><a href="/python/" class="nav-link">
  Python
</a></li></ul></li><li class="dropdown-item"><h4>
          后端开发技术
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/web/" class="nav-link">
  Web
</a></li><li class="dropdown-subitem"><a href="/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/redis/" class="nav-link">
  Redis
</a></li><li class="dropdown-subitem"><a href="/big-data/" class="nav-link">
  大数据
</a></li></ul></li><li class="dropdown-item"><h4>
          学科基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/software-engineering/" class="nav-link">
  软件工程
</a></li><li class="dropdown-subitem"><a href="/algorithm/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          机器学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/artificial-intelligence/" class="nav-link">
  人工智能
</a></li><li class="dropdown-subitem"><a href="/deep-learning/" class="nav-link">
  深度学习
</a></li><li class="dropdown-subitem"><a href="/recommender-systems/" class="nav-link">
  推荐系统
</a></li><li class="dropdown-subitem"><a href="/quantitative-methods-for-DA-AI/" class="nav-link">
  数据分析与人工智能定量分析
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://www.github.com/ZweiRm" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/zweirm/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/ZweiRm/localhost-8080.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/" class="nav-link router-link-active">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/hello-world/" class="nav-link">
  杂谈
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="施工中笔记" class="dropdown-title"><span class="title">施工中笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="施工中笔记" class="mobile-dropdown-title"><span class="title">施工中笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          编程语言
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/kotlin/" class="nav-link">
  Kotlin
</a></li><li class="dropdown-subitem"><a href="/python/" class="nav-link">
  Python
</a></li></ul></li><li class="dropdown-item"><h4>
          后端开发技术
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/web/" class="nav-link">
  Web
</a></li><li class="dropdown-subitem"><a href="/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/redis/" class="nav-link">
  Redis
</a></li><li class="dropdown-subitem"><a href="/big-data/" class="nav-link">
  大数据
</a></li></ul></li><li class="dropdown-item"><h4>
          学科基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/software-engineering/" class="nav-link">
  软件工程
</a></li><li class="dropdown-subitem"><a href="/algorithm/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          机器学习
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/artificial-intelligence/" class="nav-link">
  人工智能
</a></li><li class="dropdown-subitem"><a href="/deep-learning/" class="nav-link">
  深度学习
</a></li><li class="dropdown-subitem"><a href="/recommender-systems/" class="nav-link">
  推荐系统
</a></li><li class="dropdown-subitem"><a href="/quantitative-methods-for-DA-AI/" class="nav-link">
  数据分析与人工智能定量分析
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://www.github.com/ZweiRm" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/zweirm/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/ZweiRm/localhost-8080.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/java/" aria-current="page" class="sidebar-link">Java 概述</a></li><li><a href="/java/grammars.html" class="sidebar-link">语法</a></li><li><a href="/java/object-oriented.html" aria-current="page" class="active sidebar-link">面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-1-概述" class="sidebar-link">3.1 概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-1-1-面向过程" class="sidebar-link">3.1.1 面向过程</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-1-2-面向对象" class="sidebar-link">3.1.2 面向对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-2-类和对象" class="sidebar-link">3.2 类和对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-2-1-类" class="sidebar-link">3.2.1 类</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-2-2-对象" class="sidebar-link">3.2.2 对象</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-2-3-this" class="sidebar-link">3.2.3 this</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-2-4-super" class="sidebar-link">3.2.4 super</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-3-方法" class="sidebar-link">3.3 方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-3-1-构造方法" class="sidebar-link">3.3.1 构造方法</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-3-2-方法的使用" class="sidebar-link">3.3.2 方法的使用</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-3-3-可变参数" class="sidebar-link">3.3.3 可变参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-4-代码块" class="sidebar-link">3.4 代码块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-4-1-构造代码块" class="sidebar-link">3.4.1 构造代码块</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-4-2-局部代码块" class="sidebar-link">3.4.2 局部代码块</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-5包" class="sidebar-link">3.5包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-5-1-包的声明" class="sidebar-link">3.5.1 包的声明</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-5-2-包的导入" class="sidebar-link">3.5.2 包的导入</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-5-3-jdk-常用包" class="sidebar-link">3.5.3 JDK 常用包</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-6-模块" class="sidebar-link">3.6 模块</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-7-封装与继承" class="sidebar-link">3.7 封装与继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-7-1-形式" class="sidebar-link">3.7.1 形式</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-7-2-单继承与多继承" class="sidebar-link">3.7.2 单继承与多继承</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-7-3-直接继承与间接继承" class="sidebar-link">3.7.3 直接继承与间接继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-8-多态" class="sidebar-link">3.8 多态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-8-1-编译时多态" class="sidebar-link">3.8.1 编译时多态</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-8-2-运行时多态" class="sidebar-link">3.8.2 运行时多态</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-9-权限修饰符" class="sidebar-link">3.9 权限修饰符</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-10-非权限修饰符" class="sidebar-link">3.10 非权限修饰符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-10-1-静态" class="sidebar-link">3.10.1 静态</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-10-2-最终" class="sidebar-link">3.10.2 最终</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-10-3-抽象" class="sidebar-link">3.10.3 抽象</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-11-接口" class="sidebar-link">3.11 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-11-1-接口的实现" class="sidebar-link">3.11.1 接口的实现</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-11-2-接口的多重继承" class="sidebar-link">3.11.2 接口的多重继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-内部类" class="sidebar-link">3.12 内部类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-1-方法内部类" class="sidebar-link">3.12.1 方法内部类</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-2-成员内部类" class="sidebar-link">3.12.2 成员内部类</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-3-静态内部类" class="sidebar-link">3.12.3 静态内部类</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-4-匿名内部类" class="sidebar-link">3.12.4 匿名内部类</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-5-内部接口" class="sidebar-link">3.12.5 内部接口</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-12-6-lambda-表达式" class="sidebar-link">3.12.6 Lambda 表达式</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-泛型" class="sidebar-link">3.13 泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-1-泛型类型" class="sidebar-link">3.13.1 泛型类型</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-2-泛型方法" class="sidebar-link">3.13.2 泛型方法</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-3-有界类型参数" class="sidebar-link">3.13.3 有界类型参数</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-4-通配" class="sidebar-link">3.13.4 通配</a></li><li class="sidebar-sub-header"><a href="/java/object-oriented.html#_3-13-5-类型擦除" class="sidebar-link">3.13.5 类型擦除</a></li></ul></li></ul></li><li><a href="/java/API-introduction.html" class="sidebar-link">应用程序编程接口</a></li><li><a href="/java/API-lang.html" class="sidebar-link">API-语言基础类库 (Package java.lang)</a></li><li><a href="/java/API-util.html" class="sidebar-link">API-工具类库 (Package java.util)</a></li><li><a href="/java/API-io.html" class="sidebar-link">API-输入/输出类库 (Package java.io)</a></li><li><a href="/java/jvm.html" class="sidebar-link">Java 虚拟机</a></li><li><a href="/java/references.html" class="sidebar-link">参考文献或资料</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <h2 id="_3-1-概述"><a href="#_3-1-概述" class="header-anchor">#</a> 3.1 概述</h2> <h3 id="_3-1-1-面向过程"><a href="#_3-1-1-面向过程" class="header-anchor">#</a> 3.1.1 面向过程</h3> <p>面向过程注重过程，强调完成这个过程的具体动作。<br>
其设计理念是<a href="/java/语法.html/#顺序结构">自顶向下，逐步求精</a>的。</p> <h3 id="_3-1-2-面向对象"><a href="#_3-1-2-面向对象" class="header-anchor">#</a> 3.1.2 面向对象</h3> <p>面向对象 (Object-Oriented) 注重对象，当我们拥有这个对象时，我们就拥有了这个对象所具有的一切功能。<br>
面向对象技术最大的三个特征是：<strong>封装</strong>，<strong>继承</strong>和<strong>多态</strong>。</p> <h2 id="_3-2-类和对象"><a href="#_3-2-类和对象" class="header-anchor">#</a> 3.2 类和对象</h2> <h3 id="_3-2-1-类"><a href="#_3-2-1-类" class="header-anchor">#</a> 3.2.1 类</h3> <p>类 (Class) 是 Java 程序设计语言的基础。<br>
类似于显示生活中“种类”的概念，Java 中的类也是一种对某类事物进行抽象和归并。<br>
我们对某类事物进行抽象分析，去粗取精，由表及里，判断出这类事物最本质的特征，并用 Java 中预定的手法进行表述，就形成了一个类。<br>
一个类包含两大内容：<strong>属性</strong>和<strong>方法</strong>（也称“<strong>成员变量</strong>”和“<strong>成员方法</strong>”）。</p> <div class="custom-block tip"><p class="custom-block-title">成员变量和局部变量的区别</p> <ol><li><p>定义位置不同：</p> <ul><li><p>成员变量是定义在类内方法外</p></li> <li><p>局部变量是定义在方法或者语句内部</p></li></ul></li> <li><p>作用域不同：</p> <ul><li><p>成员变量作用域整个类</p></li> <li><p>局部变量只能在定义的方法或者语句内部使用</p></li></ul></li> <li><p>内部存储位置不同：</p> <ul><li><p>成员变量存在堆内存中，并且在堆内存中自动的赋予默认值</p></li> <li><p>局部变量是存储在栈内存中，不会自动给值</p></li></ul></li> <li><p>生命周期不同：</p> <ul><li><p>成员变量是随着对象的创建而加载到堆内存中，随着对象的回收而释放;</p></li> <li><p>局部变量在方法或者语句执行的时候才会创建，随着方法或者语句的结束而立即移除栈内存</p></li></ul></li></ol></div> <h3 id="_3-2-2-对象"><a href="#_3-2-2-对象" class="header-anchor">#</a> 3.2.2 对象</h3> <p>对象 (Object) 是对类的实例化。<br>
我们可以通过某类的具体对象来进行具体操作。<br>
使用<code>new</code>关键字可以创建新的对象，使用<code>.</code>运算符获取并使用该对象所具有的方法。<br>
对象在程序中传递时，传递的是引用地址而不是数据本身。</p> <h3 id="_3-2-3-this"><a href="#_3-2-3-this" class="header-anchor">#</a> 3.2.3 <code>this</code></h3> <ul><li><p><code>this</code>关键字</p> <ul><li><p><code>this</code>关键字可以表述一个对当前对象自身的引用。</p></li> <li><p>在本类中使用<code>this</code>可以调用本类的<strong>非静态方法</strong>和<strong>非静态属性</strong>。</p></li></ul></li> <li><p><code>this()</code>语句</p> <ul><li><p>表示在本类的构造方法中调用<strong>本类</strong>的其他的对应形式的构造函数。</p></li> <li><p>必须放在构造函数的第一行。</p></li></ul></li></ul> <h3 id="_3-2-4-super"><a href="#_3-2-4-super" class="header-anchor">#</a> 3.2.4 <code>super</code></h3> <ul><li><p><code>super</code>关键字</p> <ul><li><p><code>super</code>关键字用以表示对父类对象的引用。</p></li> <li><p>表示在子类中调用父类中的方法和属性。</p></li></ul></li> <li><p><code>super()</code>语句</p> <ul><li><p>表示子类的构造方法中，调用父类中对应形式的构造方法。</p></li> <li><p>必须写在子类构造函数的第一行。</p></li> <li><p>每一个子类的构造函数都直接或间接的含有<code>super()</code>语句。</p></li> <li><p>如果父类中没有提供无参构造，那么此时子类的构造函数中必须手动添加一个<code>super()</code>语句。</p></li></ul></li></ul> <h2 id="_3-3-方法"><a href="#_3-3-方法" class="header-anchor">#</a> 3.3 方法</h2> <p>方法 (Method) , 也称为函数。<br>
为实现代码复用，需要将代码进行封装。这种封装的形式就是方法。<br>
方法在定义好之后，必须明确返回值类型。若方法有明确的返回值类型，还要确保方法有返回值。</p> <p><strong>作用</strong>：</p> <ul><li><p>提高代码复用性。</p></li> <li><p>使代码结构更加清晰。</p></li> <li><p>便于模块化开发。</p></li></ul> <p><strong>方法签名</strong>：一个方法由其修饰符、返回值类型、方法名和形式参数唯一确定，这一组数据称为方法签名。<br>
定义：<code>修饰符 返回值类型 方法名(形式参数) {...}</code><br>
例如：<code>public void method(int num1, int num2) {...}</code></p> <h3 id="_3-3-1-构造方法"><a href="#_3-3-1-构造方法" class="header-anchor">#</a> 3.3.1 构造方法</h3> <p>与类同名且没有返回值类型。<br>
可以被重载。<br>
构造函数中可以存在<code>return</code>语句，用于规避不合理的数据。<br> <strong>作用</strong>：用于创建对象（标识对象创建的开始和结束）</p> <h3 id="_3-3-2-方法的使用"><a href="#_3-3-2-方法的使用" class="header-anchor">#</a> 3.3.2 方法的使用</h3> <ul><li><p>方法递归<br> <strong>核心</strong>：方法调用自己本身</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>需要控制好结束条件，若递归层数太深，则出现栈溢出错误。</p></div></li> <li><p>方法重载 (Method Overload)<br>
详见<a href="#%E5%A4%9A%E6%80%81">多态</a>。</p></li> <li><p>方法覆盖 (Method Override)<br>
详见<a href="#%E5%A4%9A%E6%80%81">多态</a>。</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>在传递参数的时候，对于基本类型而言，传递的实际值；对于引用类型而言，传递的是地址。<br>
例如在传递数组对象时，只要地址不发生改变，方法中的一切变化会作用于原数组。</p></div> <h3 id="_3-3-3-可变参数"><a href="#_3-3-3-可变参数" class="header-anchor">#</a> 3.3.3 可变参数</h3> <p>Java 允许方法的参数列表中参数个数是不限定的。本质上是一个数组。<br>
语法：<code>修饰符 返回值类型 方法名(类型... 参数名) {...}</code><br>
对于可变参数，可以对其传入多个/一个/不传值。<br>
每个方法只允许定义一个可变参数，切必须放在参数列表的末尾。</p> <h2 id="_3-4-代码块"><a href="#_3-4-代码块" class="header-anchor">#</a> 3.4 代码块</h2> <h3 id="_3-4-1-构造代码块"><a href="#_3-4-1-构造代码块" class="header-anchor">#</a> 3.4.1 构造代码块</h3> <ul><li><p>定义在类内。</p></li> <li><p>也称“初始化代码块”，在创建对象时执行构造方法之前先执行。</p></li> <li><p>用于完成一些初始化的操作。</p></li></ul> <h3 id="_3-4-2-局部代码块"><a href="#_3-4-2-局部代码块" class="header-anchor">#</a> 3.4.2 局部代码块</h3> <ul><li><p>定义在方法或代码块中。</p></li> <li><p>限制变量的生命周期和使用范围。</p></li> <li><p>可以提高内存的利用率。</p></li></ul> <h2 id="_3-5包"><a href="#_3-5包" class="header-anchor">#</a> 3.5包</h2> <p>包是类的容器，提供了解决命名空间冲突的方案。<br>
包在实际项目中对应了文件夹。对于一个项目，包的创建一般遵循倒域名的形式<br>
例如：<code>package io.localhost-8080.pojo</code></p> <h3 id="_3-5-1-包的声明"><a href="#_3-5-1-包的声明" class="header-anchor">#</a> 3.5.1 包的声明</h3> <ul><li><p>使用<code>package</code>关键字声明定义一个包。</p></li> <li><p>一个<code>.java</code>文件只允许存在一个<code>package</code>语句。</p></li> <li><p>包的声明必须放在<code>.java</code>文件的首行。</p></li></ul> <h3 id="_3-5-2-包的导入"><a href="#_3-5-2-包的导入" class="header-anchor">#</a> 3.5.2 包的导入</h3> <ul><li><p>使用<code>import</code>关键字来导入别的包。</p></li> <li><p><code>*</code>为通配符，表示导入该包下所有类（不包括子包中的类）。</p></li></ul> <h3 id="_3-5-3-jdk-常用包"><a href="#_3-5-3-jdk-常用包" class="header-anchor">#</a> 3.5.3 JDK 常用包</h3> <ul><li><p><code>java.lang</code>：核心包，在程序启动时自动加载到方法区，不需要手动导入</p></li> <li><p><code>java.util</code>：工具包，存放简化操作的工具类</p></li> <li><p><code>java.io</code>：数据传输</p></li> <li><p><code>java.net</code>：网络传输</p></li> <li><p><code>java.math</code>：数学运算</p></li> <li><p><code>java.sql</code>：数据库相关</p></li> <li><p><code>java.awt</code>：图形用户界面</p></li> <li><p><code>java.security</code>：数据安全</p></li> <li><p><code>javax.xxx</code>：扩展</p></li> <li><p><code>org.xxx</code>：第三方厂商、开源社区提供的包</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>包名不能以<code>java</code>、<code>javax</code>或者<code>org</code>开头。</p></li> <li><p>同包，或<code>lang</code>包下的类不使用<code>import</code>语句导入</p></li></ul></div> <h2 id="_3-6-模块"><a href="#_3-6-模块" class="header-anchor">#</a> 3.6 模块<span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java 9.0+</span></h2> <p>Java 在 9.0 引入了平台模块系统(Java Platform Module System, JPMS)。模块是一个命名的、自我描述的代码与数据的集合。每个模块被组织成多个包、相关的资源文件和静态信息，每个包中又包含类与接口。<br>
通过引入模块化系统，可以提供 JRE 定制化；避免类路径加载机制带来的依赖混乱；更强大的封装，声明哪些组件可以访问哪些不可以；它也配合 JVM 的优化提升了 Java 的性能。</p> <p>语法：<code>module 名称 {...}</code><br>
同样使用倒域名形式来命名模块。</p> <ul><li>依赖
<ul><li>普通依赖<br>
在大括号中，如果有其他模块需要被依赖进来时使用关键词 <code>requires 模块名</code></li> <li>可选依赖<br>
指定模块在编译时必要但运行时可选，用关键字 <code>requires static 模块名</code> 指明</li> <li>隐含可读依赖<br>
指定对另一个模块的依赖并确保访问当前模块的模块也会依赖该模块，用关键字 <code>requires transitive 模块名</code> 指明</li></ul></li> <li>导出
<ul><li>普通导出<br>
当需要指定模块中哪些包可以被其他模块使用时使用关键字 <code>exports 包名</code>. 被导出的包的公共类型是出于可见窗台的。当一个模块没有 <code>exports</code> 项时，它不向其他模块输出任何类型</li> <li>指向导出<br>
当需要明确模块中的某个包只向某些特定模块导出时，使用 <code>exports 包名 to 模块名, 模块名, ...</code> 指明。被指明的模块是多个时，其之间用逗号隔开。也称为合资格导出</li></ul></li> <li>使用<br>
需配合 service 的概念使用。表示该模块使用了某 service.<br>
当一个包中包含了一些接口或者抽象类的具体实现时，这个实现的具体实例称为一个 service.<br> <code>uses 接口/抽象类</code><br>
这个命令表示当前模块是某些 service 的消费者。</li> <li>提供<br>
需配合 service 的概念使用。表示该模块提供了某些 service 的实现。<br> <code>provides 接口/抽象类 with 接口或抽象类的实现类名</code><br>
其中 <code>provides</code> 后面跟的接口或抽象类名就会是其他模块的使用命令中 <code>uses</code> 后面的内容。<br>
这个命令表示当前模块是某些 service 的生产者。</li> <li>开放<br>
为了强封装性，模块默认不可以通过反射来访问其他模块中的类型，除非它们是公有的
<ul><li>仅运行时可访问某包<br>
当想要求一个模块当中的包只能在运行时被其他模块所访问时，使用命令 <code>opens 包名</code><br>
该命令也符合反射</li> <li>仅某模块可运行时可访问某包<br>
当想指定模块中的某个包只能在运行时被指定的模块所访问时，使用命令 <code>opens package to 包名, 包名, ...</code><br>
该命令也符合反射</li> <li>整个模块运行时可访问<br>
当整个模块里的包都可以在运行时被其他模块所访问时，使用命令：<br> <code>open module 模块名 {}</code></li></ul></li></ul> <p>模块的声明源文件被保存为 <code>module-info.java</code> 存放在模块的根目录中。它会被编译成 <code>module-info.class</code> 而输出到输出目录。这样做的目的是使得模块声明有一个精确的定义和可扩展的格式。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 简单声明</span>
<span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 依赖其他模块的模块</span>
<span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar</span> <span class="token punctuation">{</span>
    <span class="token keyword">requires</span> <span class="token namespace">io<span class="token punctuation">.</span>localhost</span><span class="token operator">-</span><span class="token number">8080</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 指定可以被其他模块使用的类</span>
<span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar</span> <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>alpha</span><span class="token punctuation">;</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>beta</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上，从 Java 9.0 开始整个 Java 源码也是以模块系统形式组织的。其中表示语言基础的模块被命名为 <code>java.base</code>，它是 Java 的核心包，其他每个模块都隐式依赖基础模块。</p> <h2 id="_3-7-封装与继承"><a href="#_3-7-封装与继承" class="header-anchor">#</a> 3.7 封装与继承</h2> <p><em><strong><h3>封装</h3></strong></em><br>
将一个事物的相关信息聚集在一个逻辑单元内部的机制就是封装。</p> <p><strong>形式</strong>：方法、属性私有化（类的封装）、内部类等。</p> <p><strong>优点</strong>：提高复用性和安全性，使代码结构更加紧密。</p> <br> <p><em><strong><h3>继承</h3></strong></em><br>
对于两个类 A 和 B 来说，它们之间的关系是：B 由 A 派生而来（对于 B 类来说，它拥有 A 类的所有属性和方法），则可以说 B 类继承自 A 类。</p> <h3 id="_3-7-1-形式"><a href="#_3-7-1-形式" class="header-anchor">#</a> 3.7.1 形式</h3> <p>使用<code>extends</code>关键字实现继承。<br>
Java 仅支持单继承（一个子类只能有一个父类）。</p> <h3 id="_3-7-2-单继承与多继承"><a href="#_3-7-2-单继承与多继承" class="header-anchor">#</a> 3.7.2 单继承与多继承</h3> <ul><li><p>单继承<br>
子类只能有一个父类的继承形式。</p> <p><strong>优点</strong>：</p> <ul><li><p>可以提高代码的复用性</p></li> <li><p>可以避免方法调用的混乱，提高了方法调用的安全性</p></li></ul></li> <li><p>多继承<br>
子类可以拥有多个父类的继承形式。</p> <p><strong>优点</strong>：</p> <ul><li>代码的复用性上要优于单继承</li></ul></li> <li><p>举例</p> <ul><li><p><code>iPhone 类</code>仅继承自<code>智能设备类</code>。（单继承）</p> <p><img src="/img/%E5%8D%95%E7%BB%A7%E6%89%BF.jpg" alt="单继承"></p></li> <li><p><code>Apple Watch 类</code>同时继承自<code>时钟类</code>和<code>只能设备类</code>。（多继承）</p> <p><img src="/img/%E5%A4%9A%E7%BB%A7%E6%89%BF.jpg" alt="多继承"></p></li></ul></li></ul> <h3 id="_3-7-3-直接继承与间接继承"><a href="#_3-7-3-直接继承与间接继承" class="header-anchor">#</a> 3.7.3 直接继承与间接继承</h3> <ul><li><p>直接继承<br>
B 类直接派生于 A 类，称直接继承。</p></li> <li><p>间接继承
B 类直接派生于 A类，C 类直接派生于 B 类。则称 C 类间接继承于 A 类。<br> <img src="/img/%E9%97%B4%E6%8E%A5%E7%BB%A7%E6%89%BF.jpg" alt="间接继承"></p></li></ul> <div class="custom-block tip"><p class="custom-block-title">特别地</p> <p>子类继承自父类时，父类中这些内容子类不可见：</p> <ul><li><p><code>private</code></p></li> <li><p>代码块</p></li> <li><p>构造方法</p></li></ul></div> <h2 id="_3-8-多态"><a href="#_3-8-多态" class="header-anchor">#</a> 3.8 多态</h2> <ul><li><p>当众多对象接收到同一个消息后，可以产生不同的响应效果，这种现象称为多态。</p></li> <li><p>多态性依托于继承性。</p></li> <li><p>多态主要针对的是对象具有的行为，而不是属性。</p></li> <li><p>可以提高代码的灵活性，配合反射实现解耦。</p></li></ul> <h3 id="_3-8-1-编译时多态"><a href="#_3-8-1-编译时多态" class="header-anchor">#</a> 3.8.1 编译时多态</h3> <p>方法重载 (Method Overload)<br>
是<strong>行为多态</strong>。<br>
发生在同一个类中，方法名一致而参数列表不同。和修饰符、返回值类型、异常无关。</p> <h3 id="_3-8-2-运行时多态"><a href="#_3-8-2-运行时多态" class="header-anchor">#</a> 3.8.2 运行时多态</h3> <ul><li><p>向上造型</p> <ul><li><p>是<strong>对象多态</strong>。</p></li> <li><p>父类引用指向子类对象。<br>
代码高亮标出。</p> <p><strong>Input</strong></p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Super</span> <span class="token keyword">super</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 向上造型</span>

    <span class="token class-name">Sub</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Sub</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 向下造型</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">注意</p> <p>向下造型是不允许的，上面的例子会通过编译器检测，但运行后会抛出异常：<br> <strong>Output</strong></p> <div class="language- extra-class"><pre class="language-text"><code>java.lang.ClassCastException: class Super cannot be cast to class Sub
</code></pre></div></div></li> <li><p>使用向上造型时，编译期<strong>只检查两个类之间的关系</strong>而<strong>不检查具体用哪个类创建对象</strong></p></li> <li><p>对象方法看父类，方法内容看子类。</p></li></ul></li> <li><p>方法覆盖 (Method Override)</p> <ul><li><p>又称方法重写，是<strong>行为多态</strong>。</p></li> <li><p>发生在父子类中，双方拥有方法签名完全一致的非静态方法。</p></li> <li><p>调用方法的时候，调用的是重写后的方法。</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ol><li><p>子类重写的方法<strong>权限修饰符需大于等于父类</strong>。</p></li> <li><p>关于返回值类型</p> <ul><li><p>若<strong>父类方法返回值类型是引用数据类型</strong>，则子类重写的方法的返回值类型是父类方法返回值类型的子类或其本身。</p></li> <li><p>若<strong>父类方法返回值类型是基本数据类型</strong>，则子类重写的方法返回值类型必须和父类方法相同。</p></li></ul></li> <li><p>子类抛出的异常需为父类异常的子类。</p></li></ol></div> <p><strong>Input</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
  * 方法 mA
  * @return void
  */</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
  * 方法 mB
  * @return void
  */</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * 方法 m
  * @return B
  */</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token keyword">extends</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
  * 方法 m
  * @return A
  */</span>
  <span class="token keyword">public</span> <span class="token class-name">A</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用C类声明，用D类创建对象</span>
  <span class="token comment">// 则对象c拥有返回值类型为B的方法m()</span>
  <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 用B类声明一个变量b，来接收方法的返回值</span>
  <span class="token comment">// 方法调用的是D类中的m()</span>
  <span class="token comment">// 由于D类中m()的返回值类型是A，故最终是用子类接收父类对象</span>
  <span class="token class-name">B</span> b <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 对象b无法调用B类中的mB()</span>
  <span class="token comment">// b.mB();</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_3-9-权限修饰符"><a href="#_3-9-权限修饰符" class="header-anchor">#</a> 3.9 权限修饰符</h2> <ul><li>Java 提供了<code>public</code>, <code>protected</code>, <code>默认</code>, <code>private</code>四种访问修饰符。</li> <li>通过访问修饰符来提高程序的安全性和可维护性。</li></ul> <table><thead><tr><th style="text-align:center;">修饰符</th> <th style="text-align:center;">本类中</th> <th style="text-align:center;">同包类中 (本包)</th> <th style="text-align:center;">子类中</th> <th style="text-align:center;">其他包中 (不同包中的所有类)</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>public</code></td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td></tr> <tr><td style="text-align:center;"><code>protected</code></td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">不可以</td></tr> <tr><td style="text-align:center;"><code>默认</code></td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">同包可以</td> <td style="text-align:center;">不可以</td></tr> <tr><td style="text-align:center;"><code>private</code></td> <td style="text-align:center;">可以</td> <td style="text-align:center;">不可以</td> <td style="text-align:center;">不可以</td> <td style="text-align:center;">不可以</td></tr></tbody></table> <h2 id="_3-10-非权限修饰符"><a href="#_3-10-非权限修饰符" class="header-anchor">#</a> 3.10 非权限修饰符</h2> <h3 id="_3-10-1-静态"><a href="#_3-10-1-静态" class="header-anchor">#</a> 3.10.1 静态</h3> <ul><li><p>Java 中使用<code>static</code>关键字来标识静态。</p></li> <li><p>可以使用静态来修饰变量、方法、内部类和代码块。</p></li></ul> <h4 id="_3-10-1-1-静态变量"><a href="#_3-10-1-1-静态变量" class="header-anchor">#</a> 3.10.1.1 静态变量</h4> <ul><li><p>也称为<strong>类变量</strong>。</p></li> <li><p>随着类的加载而被加载到方法区中，在其内部自动赋<a href="/java/语法.html/#基本数据类型">默认值</a>。</p></li> <li><p>静态变量优先于对象而存在，故静态变量可以不通过对象，直接通过类来调用（通过对象调用也是可以被理解的）。</p></li> <li><p>该类所产生的所有对象实际上保存该静态变量在静态区中的地址。</p></li> <li><p>静态变量被该类的所有对象所共享。</p></li></ul> <p><img src="/img/%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98.png" alt="静态内存"></p> <p><strong>路标 -&gt;</strong> <a href="/java/#内存分区">Java 内存分区</a>。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>静态变量<strong>不能</strong>定义在构造代码块中</p></li> <li><p>在构造代码块中<strong>可以</strong>对静态变量赋值</p></li></ul> <p><strong>Input</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">OneClass</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> iSta<span class="token punctuation">;</span>

  <span class="token punctuation">{</span>
    iSta <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div></div> <h4 id="_3-10-1-2-静态方法"><a href="#_3-10-1-2-静态方法" class="header-anchor">#</a> 3.10.1.2 静态方法</h4> <ul><li><p>也称为<strong>类方法</strong>。</p></li> <li><p>在类加载的时候加载到方法区中的静态区。只存储在静态区，方法被调用时在栈内存中执行。</p></li> <li><p>静态方法<strong>先于对象而存在</strong>，静态方法可通过类名或对象调用，不能直接使用本类中的非静态方法和非静态属性。</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>静态方法中<strong>不能</strong>定义静态变量</p></li> <li><p>静态方法中<strong>不能</strong>直接调用类中的非静态方法</p></li> <li><p><code>main()</code>中<strong>不能</strong>使用<code>this</code>或<code>super</code></p></li> <li><p>静态方法<strong>不能</strong>重写</p></li> <li><p>父子类中<strong>可以</strong>存在方法签名一致的静态方法
父子类中存在方法签名完全一致的方法，两者或均被<code>static</code>修饰或都不被<code>static</code>修饰</p></li> <li><p>静态方法<strong>可以</strong>被继承</p></li> <li><p>类只加载一次，只在第一次使用时加载到方法去，加载之后不再移除</p></li></ul></div> <h4 id="_3-10-1-3-静态代码块"><a href="#_3-10-1-3-静态代码块" class="header-anchor">#</a> 3.10.1.3 静态代码块</h4> <ul><li><p>类被第一次真正使用（创建对象/调用方法）时执行一次</p></li> <li><p>先父后子，先静后动</p></li></ul> <p><strong>Input</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">OneClass</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// Warning: Variable 'i' initializer '5' is redundan</span>

  <span class="token keyword">static</span> <span class="token punctuation">{</span>
    i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
    i <span class="token operator">+=</span> <span class="token number">7</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Class</span> <span class="token class-name">AnotherClass</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">{</span>
    i <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">// Warning: The value 7 assigned to 'i' is never used </span>
    i <span class="token operator">+=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// Error: Illegal forward reference</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>在<code>OneClass</code>中<br>
首先编译<code>int i</code>，后续针对<code>i</code>的操作有效。</p></li> <li><p>在<code>AnotherClass</code>中<br>
编译到<code>i = 7;</code>时检查之前代码中是否定义过变量<code>i</code>，若上文不存在该变量则将其暂时标记为一个成员变量。<br>
此时这个变量<code>i</code>不真实存在，后续对<code>i</code>的操作无效。<br>
直到找到与标记名称<code>i</code>一致的成员变量时，才会将标记的<code>i</code>真正赋值。</p></li></ul> <h3 id="_3-10-2-最终"><a href="#_3-10-2-最终" class="header-anchor">#</a> 3.10.2 最终</h3> <p><code>final</code>关键字可以用来修饰数据（成员变量），方法（成员方法）和类。</p> <h4 id="_3-10-2-1-常量"><a href="#_3-10-2-1-常量" class="header-anchor">#</a> 3.10.2.1 常量</h4> <p>当<code>final</code>修饰数据时，这个数据称为常量。<strong>定义后不可修改</strong>。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>成员常量<strong>需要在对象创建完成前进行赋初值，且只能赋值一次</strong>。</p></li> <li><p>若常量类型为<strong>基本数据类型，其实际值不可变</strong>；若常量类型为<strong>引用数据类型，其地址不可变</strong>。</p></li> <li><p>若常量是静态常量，<strong>需要在类加载之前进行赋值</strong>。</p></li></ul></div> <h4 id="_3-10-2-2-最终方法"><a href="#_3-10-2-2-最终方法" class="header-anchor">#</a> 3.10.2.2 最终方法</h4> <p>当<code>final</code>修饰方法时，这个方法称为最终方法。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>最终方法<strong>不能被重写，可以被重载，可以被继承</strong>。</p></div> <h4 id="_3-10-2-3-最终类"><a href="#_3-10-2-3-最终类" class="header-anchor">#</a> 3.10.2.3 最终类</h4> <p>当<code>final</code>修饰类时，这个类称为最终类。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>最终类<strong>不能被继承</strong>。</p></li> <li><p>最终类<strong>不能拥有匿名内部类</strong>。</p></li></ul></div> <h3 id="_3-10-3-抽象"><a href="#_3-10-3-抽象" class="header-anchor">#</a> 3.10.3 抽象</h3> <p>在 Java 中，为了体现开闭原则引出了抽象的概念，利用抽象可以做到面向抽象编程。利用面向抽象编程，我们在编写代码时在宏观层面不关心类中具体实现而只关心类的操作。</p> <h4 id="_3-10-3-1-抽象方法"><a href="#_3-10-3-1-抽象方法" class="header-anchor">#</a> 3.10.3.1 抽象方法</h4> <ul><li><p>当需要子类存在一些名称一致但细节不同的方法时，可以在父类中事先声明出这些方法。</p></li> <li><p>此时的声明行为无需为其编写方法体，使用这种方式构成的方法称为<strong>抽象方法</strong>，使用关键字<code>abstract</code>修饰。</p></li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>抽象方法所在类<strong>必须是抽象类</strong></p></li> <li><p>抽象方法<strong>必须被重写</strong>，子类继承抽象类后<strong>必须重写其中的抽象方法</strong></p></li> <li><p><strong>抽象方法之间可以重载</strong>（重载只关注方法名和参数列表）</p></li> <li><p>抽象方法的<strong>权限是<code>默认</code>，要求子类必须同包</strong></p></li></ul></div> <div class="custom-block danger"><p class="custom-block-title">注意</p> <ul><li><p>抽象方法<strong>不能使用<code>static</code>修饰</strong>（静态方法隶属于类）</p></li> <li><p>抽象方法<strong>不能使用<code>final</code>修饰</strong>（最终方法无法被重写，不符合抽象方法的规则）</p></li> <li><p>抽象方法<strong>不能使用<code>private</code>修饰</strong>（造成子类不可见，进而无法重载）</p></li> <li><p><strong>最终类不能是抽象类</strong>（最终类无法被继承，进而其方法也无法被重载）</p></li></ul></div> <h4 id="_3-10-3-2-抽象类"><a href="#_3-10-3-2-抽象类" class="header-anchor">#</a> 3.10.3.2 抽象类</h4> <p>被<code>abstract</code>修饰的类称为抽象类。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>抽象类<strong>不能创建对象</strong></p></li> <li><p>抽象类中<strong>存在构造方法</strong></p></li> <li><p>抽象类中<strong>可以存在非抽象方法和属性</strong></p></li></ul></div> <h2 id="_3-11-接口"><a href="#_3-11-接口" class="header-anchor">#</a> 3.11 接口</h2> <ul><li><p>类似于类的引用类型。</p></li> <li><p>使用关键字 <code>interface</code> 表示</p></li> <li><p>接口中方法默认且只能为抽象方法。<span class="badge error" style="vertical-align:top;" data-v-15b7b770>&lt; Java SE 7.0</span></p> <ul><li>在接口中，使用 <code>default</code> 关键字修饰的方法可以拥有方法体，可以给所有具体实现对象扩展功能。<span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java SE 8.0 +</span></li> <li>接口中也可以存在静态方法，要求该方法拥有方法体。这样的方法可以直接通过接口名打点获取到。<span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java SE 8.0 +</span></li></ul></li> <li><p>接口中的数据都为公共的静态常量（被 <code>final</code>, <code>static</code> 和 <code>public</code> 修饰的成员变量）</p></li></ul> <div class="custom-block tip"><p class="custom-block-title">接口与抽象</p> <p>类似于抽象类，它也是一个同于体现开闭原则的设计。在编写代码时，利用接口可以做到只关心类的操作而不关心具体实现，等之后在具体实现的层面再做具体考量。但不同于抽象，接口着重在系统架构中设计方法层面发挥作用，定义各功能模块之间的通信；而抽象在代码实现层面发挥作用，体现代码重用。</p> <p>利用接口和抽象带来的面向抽象编程，就可以通过多态的形式来完成开闭原则。下面给出一个简单的例子：<br>
现在有这样一个系统，它的用户拥有登录功能。但登录功能在一个时刻仅能一个人登录（意味着入口函数只能有一个实例）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// User 类</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;User login.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在入口方法利用这个类生成实例来执行这样的操作：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是之后系统有新的需求：引入管理员角色来管理系统。理所应当地，他们也拥有登录功能。此时对原有代码进行改造。<br>
简单思考：<br>
首先增加一个新的类：Admin 而不直接将 User 类改为 Admin。<br>
之后对入口方法的实例进行改造，显然直接将 User 相关代码改为 Admin 会打破开闭原则，所以仍然有问题。</p> <p>我们这里引入接口的概念而重新设计整个系统。<br>
对于 Admin 和 User，我们抽象出一个更高层的 Person 接口，它拥有登录方法的设计。而 Admin 与 User 类作为 Person 的具体实现，重写定义在接口里的登录方法。（这样体现了功能模块设计只考虑具体方法，而到实现层再考虑具体实现）<br>
在入口方法中，我们利用向上造型，使用 Person 接口来声明变量，具体的实例化根据需要进行改变。（这样就体现了开闭原则）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 统一的人员接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体实现</span>
<span class="token keyword">class</span> <span class="token class-name">Admin</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Admin login.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;User login.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主函数</span>
<span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 向上造型创建实例</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Admin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 必要时可以写 Person person = new User();</span>
        person<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <h3 id="_3-11-1-接口的实现"><a href="#_3-11-1-接口的实现" class="header-anchor">#</a> 3.11.1 接口的实现</h3> <ul><li><p>和抽象类类似，接口也可以有具体化的实现，称为实现(implements)。</p></li> <li><p>使用关键字 <code>implements</code> 来使一个类变为目标接口的实现类。</p> <ul><li><p>当类成为某接口（们）的实现类后，要求实现接口中定义的所有抽象方法。</p></li> <li><p>一个类可以实现多个接口，不过可能会造成方法混乱。</p></li></ul></li></ul> <h3 id="_3-11-2-接口的多重继承"><a href="#_3-11-2-接口的多重继承" class="header-anchor">#</a> 3.11.2 接口的多重继承</h3> <p><strong>接口可以多重继承</strong>，使用 <code>extends</code> 关键字来继承其他接口。</p> <div class="custom-block tip"><p class="custom-block-title">特别地</p> <p>对于引用数据类型的强制转换有：</p> <blockquote><ul><li>在进行强制类型转换时，编译器会检查两个类之间是否存在继承关系
<ul><li><p>若存在继承关系，则编译时会通过，但运行时不一定</p></li> <li><p>若不存在继承关系，编译时会报错</p></li></ul></li></ul> <p>→ 详见<a href="/java/语法.html/#引用类型的强制类型转换">引用类型的强制类型转换</a></p></blockquote> <p>由于接口之间可以多继承，接口和类之间可以多实现，所以会形成复杂的图状结构。在这样的结构中寻找根是很困难的，为提高效率，Java 在编译时会<strong>放弃检查类于接口是否存在实现关系</strong>。</p></div> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ul><li><p>接口<strong>不能被实例化</strong>。</p></li> <li><p>接口中<strong>不允许定义构造方法</strong>，<strong>编译完成后会产生 <code>.class</code> 文件</strong>，但<strong>接口不是类</strong>。</p></li> <li><p>接口<strong>默认只能被 <code>public</code> 修</strong>饰，且实现接口的类中的<strong>具体实现方法也只能被 <code>public</code> 所修饰</strong>。</p></li> <li><p>接口中的<strong>方法默认被 <code>public</code> 和 <code>abstract</code> 修饰</strong>。</p></li> <li><p>接口<strong>可作为模板</strong>，用于反射中来实现解耦。</p></li></ul></div> <h2 id="_3-12-内部类"><a href="#_3-12-内部类" class="header-anchor">#</a> 3.12 内部类</h2> <p>定义在类或者接口内部的类称为内部类。</p> <h3 id="_3-12-1-方法内部类"><a href="#_3-12-1-方法内部类" class="header-anchor">#</a> 3.12.1 方法内部类</h3> <ul><li><p>定义在方法中的类。</p></li> <li><p>只能在<strong>定义它的方法中使用</strong>。</p></li> <li><p>方法内部类中<strong>不能定义静态属性和静态方法</strong>，但<strong>静态常量是允许定义的</strong>。</p></li> <li><p>方法内部类<strong>可以使用外部类中的一些属性和方法</strong>。<strong>但如果使用的是当前方法的数据时，要求这个数据为常量 (自动被 <code>final</code> 修饰，不可以被修改)</strong>。</p></li> <li><p>在内部类中使用 <code>this</code> 关键字表示当前该内部类的对象。</p></li></ul> <h3 id="_3-12-2-成员内部类"><a href="#_3-12-2-成员内部类" class="header-anchor">#</a> 3.12.2 成员内部类</h3> <ul><li>定义在类的内部，方法外部的类。</li></ul> <h3 id="_3-12-3-静态内部类"><a href="#_3-12-3-静态内部类" class="header-anchor">#</a> 3.12.3 静态内部类</h3> <p>使用 <code>static</code> 关键字修饰的内部类。</p> <h3 id="_3-12-4-匿名内部类"><a href="#_3-12-4-匿名内部类" class="header-anchor">#</a> 3.12.4 匿名内部类</h3> <ul><li><p>类体定义和对象创建写在一起的形式，没有名称，只使用一次。</p></li> <li><p>本质上是继承了对应的类或是实现了对应的接口（只要一个类允许被继承，那么它就可以拥有匿名内部类的形式）。</p></li> <li><p>若匿名内部类定义在方法中，则其使用规则同方法内部类一致。</p></li> <li><p>若匿名内部类定义在类中，则其使用规则同成员内部类一致。</p></li></ul> <h3 id="_3-12-5-内部接口"><a href="#_3-12-5-内部接口" class="header-anchor">#</a> 3.12.5 内部接口</h3> <ul><li><p>定义在类或接口中的接口。</p></li> <li><p>类中定义的接口，接口中定义的类，接口中定义的接口，默认都用 <code>static</code> 修饰。</p></li></ul> <h3 id="_3-12-6-lambda-表达式"><a href="#_3-12-6-lambda-表达式" class="header-anchor">#</a> 3.12.6 Lambda 表达式 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java 8.0+</span></h3> <ul><li>Lambda 表达式是 Java 8.0 提供的特性，它也被成为箭头函数、匿名函数和闭包。它体现了代码即数据（Code as Data）的思想。通过传统方法利用接口和匿名内部类等方法来实现将代码封装为数据的手段存在语法冗余、<code>this</code> 关键字在内部类中绑定和访问有误区、变量捕获有特殊要求、数据控制不友好等问题。Lambda 表达式进行了优化。它本质上只是语法上的优化而不是新的内容。</li> <li>Lambda 表达式是一种轻量级函数编程的思想，可以使得代码聚焦于数据逻辑处理。</li> <li><code>-&gt;</code> 是 Lambda 表达式的核心操作符，在它左边是参数列表，右侧是操作表达式。</li> <li>Lambda 表达式只能操作一个方法。它的本质就是对函数式接口的实现。</li></ul> <p><strong>函数式接口 Functional Interface</strong></p> <ul><li>函数式接口是只包含一个抽象方法的特殊接口。可以使用语义化检测注解 <code>@FunctionalInterface</code> 来对其进行修饰进行检查。</li> <li>因为 Java 8.0 提供了接口默认方法，所以可以利用默认方法来对函数式接口增加通用功能，而不是在实现类中增加。</li> <li>类似的，Java 8.0 也提供了接口中的静态方法。当业务中有需要使用类名打点直接获取方法时，可以直接在接口中定义这样的静态方法。</li> <li>*<em>虽然函数式接口要求只能存在一个抽象方法，但如果有额外的继承自 Object 类的抽象方法，它们也可以存在于函数式接口中。</em></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SomeFuncIntf</span> <span class="token punctuation">{</span>
    <span class="token comment">// 唯一的抽象方法</span>
    <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 默认方法</span>
    <span class="token keyword">default</span> <span class="token class-name">String</span> <span class="token function">defaultMehod</span><span class="token punctuation">(</span><span class="token class-name">String</span> parameter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 静态方法</span>
    <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">staticMehod</span><span class="token punctuation">(</span><span class="token class-name">String</span> parameter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 继承自 Object 类的其他抽象方法</span>
    <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>利用 Lambda 表达式对函数式接口编写具体实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">SomeFuncIntf</span> somefunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> parameter<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;The results&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Java 内建函数式接口</strong><br>
在 Java 8.0 中提供了一些预定义的常用函数式功能，它们被划分于 <code>java.util.function</code> 包中。</p> <ul><li><p><code>java.util.function.Predicate&lt;T&gt;</code><br>
接收参数对象 <code>T</code>, 返回一个 <code>boolean</code> 类型的结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Predicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> pre <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> intg<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> intg <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 test() 验证</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>java.util.function.Consumer&lt;T&gt;</code><br>
接收参数对象 <code>T</code>, 不返回结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> con <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> intg<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Consuming &quot;</span> <span class="token operator">+</span> intg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 accept() 验证</span>
con<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>java.util.function.Supplier&lt;T&gt;</code><br>
不接受参数，返回结果对象 <code>T</code>.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> supp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 get() 验证</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>supp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>java.util.function.Function&lt;T, R&gt;</code><br>
接收参数对象 <code>T</code>, 返回结果对象 <code>R</code>.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> func <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> msg<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;Yes&quot;</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 apply() 验证</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">&quot;No&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>java.util.function.UnaryOperator&lt;T&gt;</code><br>
接收参数对象 <code>T</code>, 返回结果对象 <code>T</code>. 它继承了 <code>Function</code>接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">UnaryOperatorr</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> uOpt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    msg <span class="token operator">+=</span> <span class="token string">&quot; done&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用继承自 Function 的 apply() 验证</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uopt<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">&quot;Yes&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>java.util.function.BinaryOperator&lt;T&gt;</code><br>
接收两个参数对象 <code>T</code>, 返回一个结果对象 <code>T</code>. 它继承了 <code>Function</code>接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> biOpt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> num1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> num2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">&gt;</span> num2 <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用继承自 Function 的 apply() 验证</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>biOpt<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <p><strong>基本语法</strong><br> <code>[接口声明] = (参数) -&gt; {代码块};</code></p> <ul><li>接口声明：与该 Lambda 表达式关联的接口的声明，用于接收结果。</li> <li>参数：与关联接口中抽象方法中声明的参数相同（包括个数相同和顺序相同）。可以不声明参数的类型，JVM 会自动通过绑定的函数式接口推断参数的类型。</li> <li>操作符：<code>-&gt;</code>.</li> <li>执行代码块：出现在操作符右侧，负责描述具体逻辑。当所需要执行的代码只有一行时，可以省略括号。当所需要执行的代码只有一行且有返回值时，可以省略括号和 <code>return</code> 关键字。</li></ul> <p><em>类型</em></p> <ul><li><p>没有参数、没有返回值的函数式接口抽象函数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 接口定义</span>
<span class="token keyword">interface</span> <span class="token class-name">LambdaWithoutReturnAndParameter</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体执行</span>
<span class="token class-name">LambdaWithoutReturnAndParameter</span> lbdNRNP <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lbdNRNP<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>带有参数，没有返回值的函数式接口抽象函数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">LambdaWithoutReturnWithParameter</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">LambdaWithoutReturnWithParameter</span> lbdNRWP <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Name: &quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;, Age: &quot;</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
lbdNRWP<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>带有参数，带有返回值的函数式接口抽象函数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">LambdaWithReturnAndParameter</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">LambdaWithReturnAndParameter</span> lbdWRWP <span class="token operator">=</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lbdWRWP<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <p><strong>变量捕获</strong><br>
Lambda 表达式可以实现在匿名内部类的参数捕获功能。</p> <ul><li>在 Lambda 表达式形式的匿名内部类中，<code>this</code> 关键字表示它所在外部类的对象。</li> <li>可以直接访问匿名内部类中的局部变量。</li> <li>可以直接访问外部类成员方法中的局部变量，但默认自动被 <code>final</code> 修饰，无法进行修改。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> globalVar <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> localVar <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span>

        <span class="token comment">// 匿名内部类</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> innerVar <span class="token operator">=</span> <span class="token string">&quot;inner&quot;</span><span class="token punctuation">;</span>

            <span class="token comment">// 使用 this 来访问全局变量</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>globalVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 访问内部类中的内部变量</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>innerVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 访问外部类成员方法的局部变量</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>localVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// localVar = &quot;hello&quot;; 不允许被修改</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>类型推断</strong><br>
Lambda 表达式参数类型自动推断<br>
在使用 Lambda 表达式来实现一个函数式接口时，JVM 会自动联系它对应的函数式接口来推断出参数的具体类型。所以在编写 Lambda 表达式时可以不用显式声明参数的类型。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 函数式接口</span>
<span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">OneFuncInterf</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">R</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">,</span> <span class="token class-name">R</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token comment">// 以函数式接口为参数的方法，作用是将传入的字符串加入到指定的 List 中</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">OneFuncInterf</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&gt;</span></span> interf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> interf<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Lambda 形式执行 execute 方法</span>
    <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        y<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 匿名内部类形式执行 execute 方法</span>
    <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OneFuncInterf</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">List</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">List</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>方法重载</strong><br>
在同一个类中有多个名称相同但参数列表或返回值不同的方法称为方法重载。对于参数列表是不同函数式接口的重载方法，它作为 Lambda 表达式形式实现接口时，会因为无法推断出当前对应的具体接口而报错。此时请使用传统匿名内部类形式来实现该接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token comment">// 两个内部接口</span>
    <span class="token keyword">interface</span> <span class="token class-name">IntfOne</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">interface</span> <span class="token class-name">IntfTwo</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重载方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">IntfOne</span> intf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        intf<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">IntfTwo</span> intf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        intf<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 主函数</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Main</span> main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用 Lambda 形式创建接口对象</span>
        <span class="token comment">// main.execute((String s) -&gt; {</span>
        <span class="token comment">//     System.out.println(s);</span>
        <span class="token comment">// });</span>

        <span class="token comment">// 使用匿名内部类形式创建接口对象</span>
        main<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntfOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        main<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntfTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>底层原理</strong><br>
编写简单的 Lambda 表达式代码并对其反编译查看结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Interf</span> interf <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        interf<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Interf</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>反编译 Main.class 有：</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> lambda$main$<span class="token function">0</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 具体方法实现</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中生成了静态方法 <code>lambda$main$0</code>, 即：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> lambda$main$<span class="token function">0</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>继续对整个编译过程动态编译，有：</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br></div><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Main</span>$<span class="token class-name">Lambda</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Interf</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Main</span>$$<span class="token class-name">Lambda</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>即：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Main</span>$<span class="token class-name">Lambda</span>$<span class="token number">1</span> <span class="token keyword">implements</span> <span class="token class-name">Interf</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Main</span>$$<span class="token class-name">Lambda</span>$<span class="token function">1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Main</span><span class="token punctuation">.</span>lambda$main$<span class="token function">0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 调用上面的具体实现方法</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后在执行时创建 <code>Main$Lambda$1</code> 类的对象，调用其方法进行执行。</p> <p><strong>方法引用</strong><br>
方法引用与Lambda 表达式绑定使用。</p> <ul><li>静态方法引用<br>
语法：<code>类名::方法名</code></li> <li>实例方法引用<br>
语法：创建一个类的实例后，使用 <code>对象名::方法名</code></li> <li>构造方法引用<br>
语法: <code>类名::new</code>, 使用对应的函数式接口对象接收</li></ul> <p>使用方法引用等方法来实现对 <code>Person</code> 对象集合的操作：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> gender<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">comparaByAge</span><span class="token punctuation">(</span><span class="token class-name">Person</span> p1<span class="token punctuation">,</span> <span class="token class-name">Person</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> p1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PersonUtil</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareByName</span><span class="token punctuation">(</span><span class="token class-name">Person</span> p1<span class="token punctuation">,</span> <span class="token class-name">Person</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过指定类型的构造方法初始化对象数据</span>
    <span class="token class-name">Person</span> <span class="token function">initPerson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> gender<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存储 Person 对象列表</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Amy&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;F&quot;</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    personList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">// 匿名内部类实现集合对比 (Comparator)</span>
    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>personList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o1<span class="token punctuation">,</span> <span class="token class-name">Person</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Lambda 表达式实现集合对比</span>
    <span class="token comment">// Lambda 表达式自动关联相应的函数式接口，自动推断参数类型，填充到具体逻辑中。生成具体的对象传给 sort()</span>
    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>personList<span class="token punctuation">,</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> p1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 静态方法引用实现集合对比</span>
    <span class="token comment">// 静态方法引用直接调用自己编写的逻辑关联到函数式接口，而不需要重新再写第二遍。生成具体对象，传递给 sort()</span>
    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>personList<span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">compareByAge</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 实例方法引用实现集合对比</span>
    <span class="token comment">// 直接生成一个对象，关联替换对应函数式接口匿名方法。生成对象传递给 sort()</span>
    <span class="token class-name">PersonUtil</span> personutil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>personList<span class="token punctuation">,</span> personutil<span class="token operator">::</span><span class="token function">compareByName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 构造方法引用</span>
    <span class="token comment">// 通过函数式接口获取 Person 类型的构造接口</span>
    <span class="token class-name">IPerson</span> ip <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
    <span class="token class-name">Person</span> person <span class="token operator">=</span> ip<span class="token punctuation">.</span><span class="token function">initPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Jerry&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用构造接口创建对象</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-13-泛型"><a href="#_3-13-泛型" class="header-anchor">#</a> 3.13 泛型</h2> <p>使用泛型可以在定义类、接口和函数时将某一个类型（即某一个类或者某一个接口）作为参数。它可以使得在使用不同类型作为输入下重用某些代码，效果类比形式参数。</p> <p>主要作用：</p> <ul><li>更强的编译时类型检查<br>
Java 编译器会在编译器对泛型进行检查，从而降低了整个程序在运行时发生错误的概率。</li> <li>消除类型转换<br>
例如：默认情况下 List 存放的是 <code>Object</code> 类型数据。所有其他引用类都是 <code>Object</code> 的子类，所以各类型数据都可以成功存入默认的 List 中。但在试图通过默认 List 接收一个指定类型的元素时，就会发生类型转换。如果我们对整个 List 使用泛型声明元素类型后，后续提取接收元素则不需要类型转换。<br>
默认 List:<div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>使用泛型的 List:<div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>实现泛型算法<br>
通过泛型来实现泛型算法。使其可定义、类型安全且易读。</li></ul> <h3 id="_3-13-1-泛型类型"><a href="#_3-13-1-泛型类型" class="header-anchor">#</a> 3.13.1 泛型类型</h3> <p><strong>声明泛型类型</strong><br>
对于规定了类型的类和接口，称之为泛型类型。对于类型参数，使用尖括号包裹。其中类型参数是一个大写的字母。<br>
定义语法：<code>class ClassName&lt;T1, T2, ..., Tn&gt; {...}</code></p> <p>通常我们规定类型参数字母用以下所示的来表示：</p> <ul><li><code>E</code> Element 元素 (从 Java 集合中扩展)</li> <li><code>K</code> Key 键</li> <li><code>N</code> Number 数字</li> <li><code>T</code> Type 类型</li> <li><code>V</code> Value 值</li> <li><code>S</code>, <code>U</code>, <code>V</code>, etc. 类型（单个 T 无法满足需求时，按字母表序使用 T 周围的其他字母）</li></ul> <p>举例：<br>
定义一个可以存放元素的 <code>Box</code> 类，其存放元素定义为 <code>Object</code> 类型。<code>Box</code> 类拥有获取元素的 <code>get()</code> 和存放元素的 <code>set()</code>. 因为可以存放的类型定义为 <code>Object</code>, 所以它可以接受任意引用类型的元素。则可能会造成一些无法在编译期被检查出来的错误：在代码的某一部分向 Box 中存放 <code>Integer</code> 类型的数据而另一部分代码向 Box 存放 <code>String</code> 类型的数据。这样就会造成运行时错误。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> object<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> object<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> object<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用泛型来规定 Box 只能接受某一种类型的元素：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// T stands for &quot;Type&quot;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> t<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Box 被使用时，需要指明该 Box 接受的元素类型，并且这个 Box 只能接受这样一种类型，从而避免了之前描述的错误可能。</p> <p><strong>调用与实例化泛型类型</strong><br>
当实例化一个参数化类型时，必须在尖括号中用具体的引用类型来代替定义时的字母，如：<br>
使用 <code>Box&lt;Integer&gt; intergerBox</code> 来声明一个只能存放 <code>Integer</code> 类型的 Box.<br>
使用 <code>new Box&lt;Integer&gt;()</code> 来实例化具体的可以存放 <code>Integer</code> 的 Box 对象。</p> <div class="custom-block tip"><p class="custom-block-title">钻石操作符 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java 7.0+</span> <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>Java 9.0+</span></p> <p>在 Java SE 7.0 之后，当调用泛型类型的构造函数来实例化对象时，可以不在尖括号里写出具体的类型而让编译器自动进行推断。这样的空尖括号 <code>&lt;&gt;</code> 称为钻石操作符。在 Java 9 中，它新增了对匿名内部类的支持。<br>
例如声明并实例化一个可以存放 <code>Integer</code> 类型的 Box 写为：<br> <code>Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();</code></p></div> <p><strong>多类型参数的泛型类型</strong><br>
泛型类型可以拥有多个类型参数。例如编写一个拥有键值对的容器接口和具体的实现类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Pair 容器接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体实现类：OrderedPair</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderedPair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">OrderedPair</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 声明并创建具体实例</span>
<span class="token class-name">OrderedPair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderedPair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;Even&quot;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">OrderedPair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>  p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderedPair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>参数化类型</strong><br>
设定了类型参数的泛型类型称为参数化类型。例如：<code>List&lt;String&gt;</code></p> <p>对于一个泛型类型，它声明时的类型参数也可以是一个声明了类型参数的泛型类型。<br>
例如：<br> <code>OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));</code></p> <p><strong>原始类型</strong><br>
当一个泛型类型在声明和实例化时没有声明类型参数时，称为原始类型。<br>
对于上面的泛型类型 Box 来说，省略类型参数声明之后：<code>Box rawBox = new Box();</code><br>
就是声明并实例化了 Box 的原始类型。</p> <ul><li>一个非泛型类型的普通类型不称为原始类型也无需声明类型参数。</li> <li>当使用声明了类型参数的变量接收（引用）原始类型时，会得到警告 <code>unchecked conversion</code><div class="language-java extra-class"><div class="highlight-lines"><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">Box</span> rawBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intBox <span class="token operator">=</span> rawBox<span class="token punctuation">;</span>
</code></pre></div></li> <li>当声明的原始类型变量接收（引用）泛型类型时，会得到警告 <code>unchecked invocation</code><div class="language-java extra-class"><div class="highlight-lines"><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span> rawBox <span class="token operator">=</span> intBox<span class="token punctuation">;</span>
</code></pre></div></li> <li>当声明的原始类型变量接收（引用）泛型类型并使用泛型类型的方法时，会得到警告 <code>unchecked invocation to {method}</code><div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span> rawBox <span class="token operator">=</span> stringBox<span class="token punctuation">;</span>
rawBox<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// warning: unchecked invocation to set(T)</span>
</code></pre></div></li></ul> <h3 id="_3-13-2-泛型方法"><a href="#_3-13-2-泛型方法" class="header-anchor">#</a> 3.13.2 泛型方法</h3> <p>类似泛型类型，当一个方法声明了它限定使用的类型后称为泛型方法。对于方法的泛型，它的作用域只在被声明的函数里。<br>
语法：<code>权限控制符 [静态] &lt;泛型 1, 泛型 2, ...&gt; 返回值类型 方法名(参数列表) {...}</code><br> <strong>泛型和静态的声明必须出现在返回值类型前</strong>。</p> <p>编写一个 <code>Util</code> 类，其中包含泛型方法 <code>compare()</code> 用来比较两个泛型类型 <code>Pair</code>:</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br></div><pre class="language-java"><code><span class="token comment">// Pair 类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Util 类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Util</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p1<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> p1<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
               p1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用 <code>compare()</code> 来比较两个 <code>Pair</code> 实例：</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token comment">// 实例化 Pair</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;apple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;pear&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 调用比较函数，结果由布尔变量 same 所引用</span>
<span class="token keyword">boolean</span> same <span class="token operator">=</span> <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><em>类型推断</em><br>
在调用泛型方法时，编译器可以自动推断出这个泛型方法所需要的类型参数，所以调用时的类型参数声明可以被省略。</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;apple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;pear&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> same <span class="token operator">=</span> <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-13-3-有界类型参数"><a href="#_3-13-3-有界类型参数" class="header-anchor">#</a> 3.13.3 有界类型参数</h3> <p>当限定泛型类型可接受的类型参数范围时（例如只接受某一类及其子类作为类型参数）称为有界类型参数。</p> <ul><li>使用 <code>extends</code> 关键字来设定类型参数的上界；使用 <code>super</code> 关键字来设定类型参数的下界。<br>
语法：<code>&lt;X extends 类/接口&gt;</code> 上界, <code>&lt;X super 类/接口&gt;</code> 下界<div class="language-java extra-class"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token comment">// 规定了上界的泛型方法</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;T: &quot;</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;U: &quot;</span> <span class="token operator">+</span> u<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 规定了上界的泛型类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NaturalNumber</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div></li> <li>当拥有多个界时，类型参数直接用 <code>&amp;</code> 隔开。<code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code><br>
一个具有多个界的类型变量是边界中列出的所有类型的一个子类型。如果其中一个界是一个类，必须首先指定它。<div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">C</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token operator">&amp;</span> <span class="token class-name">B</span> <span class="token operator">&amp;</span> <span class="token class-name">C</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre></div></li> <li>当一个泛型类型设定好它的类型参数范围后，可以使用这个类型参数的方法。<div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NaturalNumber</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> n<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">NaturalNumber</span><span class="token punctuation">(</span><span class="token class-name">T</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEven</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>实例：编写一个泛型数组的元素对比函数，要求计数比指定元素大的所有元素个数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">countGreaterThan</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anArray<span class="token punctuation">,</span> <span class="token class-name">T</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> e <span class="token operator">:</span> anArray<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token operator">++</span>count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在循环中，不使用 <code>e &gt; elem</code>. 因为比较运算符只适用于基本数字类型。使用有界类型参数来使用 <code>Comparable</code> 接口的 <code>compareTo()</code> 实现对比。</p> <div class="custom-block tip"><p class="custom-block-title">关于泛型的类型推断</p> <ul><li>实例化时类型参数的自动推断<br>
当调用泛型类型的构造函数来实例化对象时，可以不在尖括号里写出具体的类型而让编译器自动进行推断，称为钻石操作符。<div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>钻石操作符不可省略，否则声明的是原始类型。</li> <li>调用泛型方法时的类型推断<br>
在调用泛型方法时，编译器可以自动推断出这个泛型方法所需要的类型参数，所以调用时的类型参数声明可以被省略。<div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 泛型方法定义</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">addBox</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Box</span><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> boxes<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>

<span class="token comment">// 自动推断出调用时的类型参数是 Integer</span>
<span class="token class-name">BoxDemo</span><span class="token punctuation">.</span><span class="token function">addBox</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listOfIntegerBoxes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>构造函数类型推断<br>
构造函数也可以被写成泛型方法。是实例化时，可以类似泛型方法的类型推断而不必写出具体的类型参数。<div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">X</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// 带有类型参数的构造函数</span>
  <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实例化时，从传入的 &quot;&quot; 推断出构造函数所需要的类型参数是 String</span>
<span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> myObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></div> <h3 id="_3-13-4-通配"><a href="#_3-13-4-通配" class="header-anchor">#</a> 3.13.4 通配</h3> <p>在泛型代码中，问号（<code>?</code>）被称为通配符，代表未知类型。通配符可以在各种情况下使用：作为参数、字段或局部变量的类型；有时作为返回类型（尽管更好的编程实践要求其更具体）。<br>
注意：<strong>通配符永远不会被用作泛型方法调用、泛型类型实例创建或超类型的类型参数。</strong></p> <p><strong>上界通配</strong><br>
使用通配符可以设定泛型类型参数的上边界。<br>
语法：<code>&lt;? extends 类/接口&gt;</code>.<br>
实例：定义一个 <code>sumOfList()</code> 来获得 List 中所有元素的和。要求 List 元素可以为 <code>Number</code> 及其子类类型，和以 <code>double</code> 形式储存。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// sumOfList()，使用上界通配规定参数 List 中元素的上界为 Number</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sumOfList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> s <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Number</span> n <span class="token operator">:</span> list<span class="token punctuation">)</span>
        s <span class="token operator">+=</span> n<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 doubleValue() 来使得结果为 double 类型</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 计算 Integer 类型 list 的元素和</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> li <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sum = &quot;</span> <span class="token operator">+</span> <span class="token function">sumOfList</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 计算 Double 类型 list 的元素和</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> ld <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sum = &quot;</span> <span class="token operator">+</span> <span class="token function">sumOfList</span><span class="token punctuation">(</span>ld<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>下界通配</strong><br>
类似上界通配，使用通配符可以设定泛型类型参数的上边界。<br>
语法：<code>&lt;? super 类/接口&gt;</code>.<br>
实例：定义一个方法来计算 1 到 10 的和（1 + 2 + 3 + ... + 10），并且将每一轮的结果添加到一个 <code>List</code> 中。要求这个 <code>List</code> 存放元素的类型是 <code>Integer</code> 及其父类类型。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>无界通配</strong><br>
当在尖括号内只写一个问号时，称为无界通配，它用来表示未知类型。<br>
通常有两种适用情形：</p> <ul><li>当编写的方法可以被 <code>Object</code> 类的功能所实现</li> <li>泛型类型中的方法与参数类型无关<br>
例如泛型类型 <code>List&lt;T&gt;</code> 中，<code>List.size()</code> 和 <code>List.clear()</code> 与 <code>T</code> 具体是什么类型无关。</li></ul> <p>实例：编写一个遍历打印 List 元素的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 错误写法，这个方法只能遍历打印元素为 Object 类型的 List</span>
<span class="token comment">// 元素为其他类型的 List 不是 List&lt;Object&gt; 的子类</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> elem <span class="token operator">:</span> list<span class="token punctuation">)</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>elem <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 正确写法，使用无界通配保证元素为任何类型的 List 都是 List&lt;Object&gt; 的子类</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> elem<span class="token operator">:</span> list<span class="token punctuation">)</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>elem <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用 printList()</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> li <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>  ls <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;two&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printList</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printList</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong><code>List&lt;Object&gt;</code> 与 <code>List&lt;?&gt;</code> 是不同的。你可以在 <code>List&lt;Object&gt;</code> 中插入一个 <code>Object</code> 或者 <code>Object</code> 的任何子类型。但是你只能在 <code>List&lt;?&gt;</code> 中插入 <code>null</code>.</strong></p> <div class="custom-block warning"><p class="custom-block-title">关于继承关系</p> <p><strong>泛型类型的泛化</strong><br>
类似类之间的多态，一个父类声明可以引用子类对象（例如 <code>Object someObj = new Integer(1);</code>, 一个类型参数声明为父类的泛型类型可以存放子类元素。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> box <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
box<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK</span>
box<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">10.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span>
</code></pre></div><p>但要注意：<strong>声明了类型参数为父类的泛型类型与声明了类型参数为子类的泛型类型不构成继承关系。</strong></p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br></div><pre class="language-java"><code><span class="token comment">// 一个参数要求为 Number 为类型参数的泛型类型 Box 的函数</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">boxTest</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> doubleBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// boxTest(intBox);</span>
<span class="token comment">// boxTest(doubleBox);</span>
</code></pre></div><p><img src="/img/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%8C%96.png" alt="泛型类型的泛化"></p> <p>泛型类型之间可以通过 <code>extends</code> (类) 和 <code>implements</code> (接口)来实现继承关系。例如 <code>ArrayList&lt;E&gt;</code> 实现了 <code>List&lt;E&gt;</code>，而 <code>List&lt;E&gt;</code> 继承了 <code>Collection&lt;E&gt;</code>. 那么这三个类直接是继承关系。那么对应的，当声明了父类参数类型且后续不变时，类之间的继承关系保留，例如：<code>ArrayList&lt;String&gt;</code> 是 <code>List&lt;String&gt;</code> 的子类，而 <code>List&lt;String&gt;</code> 是 <code>Collection&lt;String&gt;</code> 的子类。<br> <img src="/img/Collection%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="Collection继承关系"></p> <p><strong>泛型类型继承关系</strong><br>
使用通配可以实现泛型类型的继承关系。<br>
对于 <code>Box&lt;Integer&gt;</code> 和 <code>Box&lt;Number&gt;</code> 来说，虽然它们之间不存在继承关系，但是它们的公共父类可以是 <code>Box&lt;?&gt;</code>.
<img src="/img/Box%E5%85%AC%E5%85%B1%E7%88%B6%E7%B1%BB.png" alt="Box的公共父类"></p> <p>利用上下界通配可以真正实现类型参数是子父类的泛型类型继承。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 泛型类型向上造型</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span>  numList <span class="token operator">=</span> intList<span class="token punctuation">;</span>  <span class="token comment">// OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt;</span>
</code></pre></div><p>对于 <code>List&lt;?&gt;</code>, <code>List&lt;Number&gt;</code>, <code>List&lt;Integer&gt;</code>, <code>List&lt;? extends Number&gt;</code>, <code>List&lt;? extends Integer&gt;</code>, <code>List&lt;? super Number&gt;</code>, <code>List&lt;? super Integer&gt;</code> 它们之间的关系为：<br> <img src="/img/List%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="List继承关系"></p></div> <p><strong>通配捕获与 Helper 函数</strong><br>
当在代码中声明了一个通配符时，编译器会去通过它周围的代码推断出这个通配符所需要的具体类型，称为通配捕获。<br>
但在某些情况下，编译器无法推断出具体所需要的类型时，就会报 <code>WildcardError</code>. 这时需要编写一些 Helper 方法来使得泛型捕获到正确的类型。</p> <p>实例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WildcardError</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会得到错误：</p> <div class="language- extra-class"><pre class="language-text"><code>WildcardError.java:6: error: method set in interface List&lt;E&gt; cannot be applied to given types;
    i.set(0, i.get(0));
     ^
  required: int,CAP#1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
1 error
</code></pre></div><p>在代码中，编译器会把参数 <code>i</code> 推断为 <code>Object</code>. 之后在 <code>foo()</code> 中调用变量 <code>i</code> 所在的 <code>List</code> 接口中的 <code>List.set(int, E)</code>. 这个函数要求第二个参数是一个类型参数，但因为编译器之前将 <code>i</code> 推断成为 <code>Object</code> 类型，所以对应 <code>i.get(0)</code> 也是 <code>Object</code> 类型。这样的结果与要求不匹配，编译器无法确定对 list 插入的值到底是何种类型而报错。</p> <p>通过编写一个 <code>fooHelper()</code> 来绕过编译器的类型安全检测：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WildcardFixed</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fooHelper</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// Helper method created so that the wildcard can be captured</span>
    <span class="token comment">// through type inference.</span>
    <span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">fooHelper</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        l<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这样以来，在 <code>foolHelper()</code> 中已经声明了类型参数是 <code>T</code>，编译器就可以在 <code>List.set(int, E)</code> 中确定第二个参数是 <code>T</code> 类型的，从而符合类型安全。</p> <p>实例 2：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WildcardErrorBad</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">swapFirst</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> l1<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Number</span> temp <span class="token operator">=</span> l1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      l1<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// expected a CAP#1 extends Number,</span>
                            <span class="token comment">// got a CAP#2 extends Number;</span>
                            <span class="token comment">// same bound, but different types</span>
      l2<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>	    <span class="token comment">// expected a CAP#1 extends Number,</span>
                            <span class="token comment">// got a Number</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体调用执行</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> li <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span>  ld <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">10.10</span><span class="token punctuation">,</span> <span class="token number">20.20</span><span class="token punctuation">,</span> <span class="token number">30.30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">swapFirst</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span> ld<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然两个 list 都符合 <code>List&lt;? extends Number&gt;</code>, 但显然 <code>Integer</code> 与 <code>Double</code> 无法匹配。这样的代码也无法编写 Helper 函数来解决。</p> <div class="custom-block tip"><p class="custom-block-title">通配使用建议</p> <p>建议通过以下规则来确定具体代码中使用上下界通配时的范围确定：<br>
将变量看做两大类型：输入型和输出型。其中，</p> <ul><li>输入型变量：向代码提供数据。</li> <li>输出型变量：保存数据，供给其他地方使用。</li></ul> <p>例如：一个函数 <code>copy(src, dest)</code>, 其中 <code>src</code> 是输入型变量， <code>dest</code> 是输出型变量。</p> <p>以此为标准，当要确定通配上下界时：</p> <ul><li>输入型变量用上界通配</li> <li>输出型变量用下界通配</li> <li>当输入型变量可以使用 <code>Object</code> 类特性时，用无界通配</li> <li>变量既有输入特性又有输出特性，不使用通配</li></ul> <p><em>这些准则并不适用于方法的返回类型。应该避免使用通配符作为返回类型，因为它迫使使用代码的程序员去处理通配符。</em></p> <p><strong>关于 <code>List&lt;? extends ...&gt;</code></strong><br>
一般认为一个 <code>List&lt;? extends ...&gt;</code> 是一个只读的 list。它的现有元素不能被增加或修改，但其实不是严格意义上的只读。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 自然数类</span>
<span class="token keyword">class</span> <span class="token class-name">NaturalNumber</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">NaturalNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 偶数类</span>
<span class="token keyword">class</span> <span class="token class-name">EvenNumber</span> <span class="token keyword">extends</span> <span class="token class-name">NaturalNumber</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">EvenNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体调用</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EvenNumber</span><span class="token punctuation">&gt;</span></span> le <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">NaturalNumber</span><span class="token punctuation">&gt;</span></span> ln <span class="token operator">=</span> le<span class="token punctuation">;</span>
<span class="token comment">// ln.add(new NaturalNumber(35));  // compile-time error</span>
</code></pre></div><p><code>List&lt;EvenNumber&gt;</code> 是 <code>List&lt;? extends NaturalNumber&gt;</code> 的子类，所以变量 <code>ln</code> 可以引用 <code>le</code> (向上造型)。但调用 <code>ln</code> 的 <code>add()</code> 去添加一个自然数到偶数 list 是不可以的。<br>
但是，仍然可以对 <code>ln</code> 进行以下操作：</p> <ul><li>添加 <code>null</code> 元素</li> <li>调用 <code>clear()</code></li> <li>获取迭代器 iterator 并调用 <code>remove()</code></li> <li>捕捉通配并写入从 list 中读到的元素</li></ul></div> <h3 id="_3-13-5-类型擦除"><a href="#_3-13-5-类型擦除" class="header-anchor">#</a> 3.13.5 类型擦除</h3> <p>Java 主要利用类型擦除来实现泛型功能，其主要作用：</p> <ul><li>如果类型参数是无界的，则用它们的界或 <code>Object</code> 类替换泛型类型中的所有类型参数。</li> <li>在必要时插入类型转换，以保持类型安全。</li> <li>生成桥接方法以保留扩展泛型类型中的多态性。</li></ul> <p>类型擦除确保不会为参数化类型创建新的类；因此，泛型不会产生运行时开销。</p> <p>也就是说，Java 所提供的泛型是在编译期实现的，当编译通过后，泛型信息（类型变量、参数化类型）都会被擦除。<br>
例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Class</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>结果会为 <code>true</code>, 它们都是 <code>ArrayList</code> 类型的。此时如果使用反射来操作 <code>c1</code> 或 <code>c2</code>, 其他它们可以存放任意类型的元素。</p> <p><strong>泛型类型的类型擦除</strong><br>
在类型擦除过程中，Java 编译器会擦除所有的类型参数，如果类型参数是有界的，则用它的第一个界来代替，如果类型参数是无界的，则用 <code>Object</code> 来代替。<br>
实例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 单链表的 Node 类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器类型擦除后的状态：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// T 是无界的，被替换为 Object</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实例2：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 设定了上界的 Node 函数</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器类型擦除后的状态：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//  T 被替换为第一个届 Comparable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Comparable</span> data<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> data<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Comparable</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>泛型方法的类型擦除</strong><br>
实例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 计数数组中元素个数</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anArray<span class="token punctuation">,</span> <span class="token class-name">T</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> e <span class="token operator">:</span> anArray<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器类型擦除后的状态：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// T 是无界的，被替换为 Object</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> anArray<span class="token punctuation">,</span> <span class="token class-name">Object</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> e <span class="token operator">:</span> anArray<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实例2：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 图形类</span>
<span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// 泛型方法 draw</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token class-name">T</span> shape<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

<span class="token comment">// 编译器类型擦除后的状态：</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token class-name">Shape</span> shape<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre></div><p><strong>保证类型安全的强制转换与桥接方法</strong><br>
实例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 类 Node</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> data<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">T</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Node.setData&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// MyNode 继承 Node</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">MyNode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyNode.setData&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用父类方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体调用</span>
<span class="token class-name">MyNode</span> mn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Node</span> n <span class="token operator">=</span> mn<span class="token punctuation">;</span>            <span class="token comment">// A raw type - compiler throws an unchecked warning</span>
n<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Causes a ClassCastException to be thrown.</span>
<span class="token class-name">Integer</span> x <span class="token operator">=</span> mn<span class="token punctuation">.</span>data<span class="token punctuation">;</span> 

<span class="token comment">// 编译器类型擦除后的状态：</span>
<span class="token class-name">MyNode</span> mn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Node</span> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyNode</span><span class="token punctuation">)</span>mn<span class="token punctuation">;</span>         <span class="token comment">// A raw type - compiler throws an unchecked warning</span>
n<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Causes a ClassCastException to be thrown.</span>
<span class="token class-name">Integer</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>mn<span class="token punctuation">.</span>data<span class="token punctuation">;</span> 
</code></pre></div><p>当一个类继承或实现了一个参数化类型/接口时，Java 编译器会创建一个桥接方法来处理泛型擦除。<br>
例如上面的例子，两个类经过类型擦除后会变为：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Node.setData&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">MyNode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyNode.setData&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时 <code>Node.setData(Object)</code> 与 <code>MyNode.setData(Integer)</code> 无法匹配。编译器则为了在类型擦除后保持多态性而创建一个桥接方法：</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token comment">// Bridge method generated by the compiler</span>
    <span class="token comment">//</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyNode.setData&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上一小节的具体调用中，<code>n.setData(&quot;Hello&quot;);</code> 调用的是桥接方法 <code>setData((Integer) data)</code>. 因为 <code>&quot;Hello&quot;</code> 与 <code>Integer</code> 不匹配而报 <code>ClassCastException</code>.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/ZweiRm/localhost-8080.github.io/edit/master/docs/java/object-oriented.md" target="_blank" rel="noopener noreferrer">帮助我改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/3/6 下午11:09:52</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/grammars.html" class="prev">
        语法
      </a></span> <span class="next"><a href="/java/API-introduction.html">
        应用程序编程接口
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><div></div></div></div>
    <script src="/assets/js/app.ed89cf52.js" defer></script><script src="/assets/js/3.f83a99be.js" defer></script><script src="/assets/js/39.ae81f180.js" defer></script><script src="/assets/js/6.99f29953.js" defer></script><script src="/assets/js/5.612dc22d.js" defer></script>
  </body>
</html>
