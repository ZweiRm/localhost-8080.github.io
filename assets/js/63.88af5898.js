(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{542:function(e,t,s){"use strict";s.r(t);var r=s(19),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[e._v("#")]),e._v(" Redis")]),e._v(" "),s("p",[e._v("Redis 是一种 NoSQL.")]),e._v(" "),s("h2",{attrs:{id:"多路复用机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多路复用机制"}},[e._v("#")]),e._v(" 多路复用机制")]),e._v(" "),s("p",[e._v("在 Redis 中，其对外提供键值对存储服务的主要流程，例如：网络 IO 和 键值对读写是由一个线程完成的。所以我们理解为 Redis 具有单线程高性能。但它在持久化、异步删除和集群数据同步等操作时是由其他线程执行的。")]),e._v(" "),s("p",[e._v("Redis 在只运行单线程的情况下，允许内核中同时存在多个监听套接字和已连接套接字。这样，内核就会持续监听这些套接字上的连接请求和数据请求，只要有请求到达就交给 Redis 线程处理。"),s("br"),e._v("\n当请求到达时，多路复用机制提供了基于事件的回调机制，即针对不同事件发生，调用相应的处理函数。事件会被放进事件队列中，Redis 单线程对事件队列进行处理。这样即可实现 Redis 无需一直轮询是否有请求实际发生，避免造成 CPU 资源浪费。")]),e._v(" "),s("h2",{attrs:{id:"参考文献或资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献或资料"}},[e._v("#")]),e._v(" 参考文献或资料")]),e._v(" "),s("p",[e._v("[1] 蒋德钧."),s("a",{attrs:{href:"https://time.geekbang.org/column/100056701",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis 核心技术与实战"),s("OutboundLink")],1),e._v(". 2020")])])}),[],!1,null,null,null);t.default=a.exports}}]);