{"remainingRequest":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\docs\\java\\README.md?vue&type=template&id=e6682e70&","dependencies":[{"path":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\docs\\java\\README.md","mtime":1554878054638},{"path":"C:\\Users\\momg\\Documents\\WORKSPACE\\Github\\localhost-8080.github.io\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1546868327989},{"path":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":1558414119184},{"path":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1546868327989},{"path":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\vue-loader\\lib\\index.js","mtime":1558414119184},{"path":"C:\\Users\\momg\\Documents\\Workspace\\Github\\localhost-8080.github.io\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":1558414126042}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"基础\"><a class=\"header-anchor\" href=\"#基础\" aria-hidden=\"true\">#</a> 基础</h1>\n<h2 id=\"关于-java\"><a class=\"header-anchor\" href=\"#关于-java\" aria-hidden=\"true\">#</a> 关于 Java</h2>\n<ul>\n<li>\n<p>1995 年 Sun 公司正式推出的一款编程语言<br>\n吸收了 C++ 的优点，去掉了其中难以理解的部分</p>\n</li>\n<li>\n<p>起初它的名字为 Oak<br>\nGreen Project 引导下开发了 Oak 语言，并在实用机器运行<br>\nSunWorld 大会正式以&quot;Java&quot;的名字发布了 1.0 版本<br>\n提出了 Java 的口号 &quot;Write once, run anywhere.&quot;</p>\n</li>\n<li>\n<p>版本变化</p>\n<ul>\n<li>Beta [1995, <strong>JDK Beta</strong>]</li>\n<li>1.0 [1996, <strong>JDK 1.0</strong>] (JVM, Applet, AWT...)</li>\n<li>1.1 [1997, <strong>JDK 1.1</strong>] (JDBC, JavaBean, 内部类...)</li>\n<li>1.2 [1998, <strong>J2SE 1.2</strong>, ...] (分解为 J2SE, J2EE, J2ME)</li>\n<li>1.3 [2000, <strong>J2SE 1.3</strong>, ...] (数学运算, Timer, ...)</li>\n<li>1.4 [2002, <strong>J2SE 1.4</strong>, ...] (正则, 日志, XML解析器, ...) 走向成熟</li>\n<li>5.0 [2004, <strong>J2SE 5.0</strong>, ...] (泛型, 自动装箱, 枚举, 便利循环, ...) 面向易用</li>\n<li>6.0 [2006, <strong>Java SE 6.0</strong>, ...] (动态语言, 垃圾回收, 类加载, ...)</li>\n<li>Sun 衰落，被 Oracle 收购</li>\n<li>7.0 [2011, <strong>Java SE 7</strong>, ...] (G1 收集器, 类加载框架, ...)</li>\n<li>8.0 [2014, <strong>Java SE 8 (LTS)</strong>, ...] (Lambda 表达式, 默认方法, ...)</li>\n<li>9.0 [2017, <strong>Java SE 9</strong>, ...] (模块系统, REPL 交互式编程, ...)</li>\n<li>10.0 [2018, <strong>Java SE 10</strong>, ...] (局部类型推测, 改进的 GC, ...)</li>\n<li>11.0 [2018, <strong>Java SE 11 (LTS)</strong>, ...] (基于嵌套的访问控制, 标准 Http 客户端, ...)</li>\n<li>12.0 [2019, <strong>Java SE 12</strong>, ...] (增强的 Switch, Constants API, ...)</li>\n</ul>\n</li>\n<li>\n<p>技术结构</p>\n<ul>\n<li>Java SE: 标准版</li>\n<li>Java EE: 企业版</li>\n<li>Java ME: 移动版</li>\n</ul>\n</li>\n<li>\n<p>跨平台性<br>\nJava 是一款拥有跨平台性的语言。这种特性的实现方式是<span id=\"JVM\"></span>JVM (Java Virtual Machine).<br>\nJava 针对每种操作系统开发了对应的 Java 虚拟机，Java 程序在编写完成后并不直接在计算机中运行，而是先提交给对应操作系统的 JVM 进行“翻译”。JVM 将 Java 代码“翻译”成当前操作系统可以“读懂”的语言后才运行。<br>\n所以 Java 语言的跨平台性得益于 JVM，但 <strong>JVM 本身不具有跨平台性</strong>。</p>\n</li>\n</ul>\n<h2 id=\"jvm-jre-和-jdk\"><a class=\"header-anchor\" href=\"#jvm-jre-和-jdk\" aria-hidden=\"true\">#</a> JVM, JRE 和 JDK</h2>\n<ul>\n<li>\n<p><a href=\"#JVM\">JVM (Java Virtual Machine)</a>, <strong>Java 虚拟机</strong>，是 Java 可以跨平台的前提。</p>\n</li>\n<li>\n<p>JRE (Java Runtime Environment), <strong>Java 运行时环境</strong>，包括 JVM、Java 平台核心类和基础 Java 平台库。</p>\n</li>\n<li>\n<p>JDK (Java Development Kit), <strong>Java 开发工具包</strong>，包括 JRE 和一些开发工具.</p>\n</li>\n</ul>\n<h2 id=\"第一个-java-程序\"><a class=\"header-anchor\" href=\"#第一个-java-程序\" aria-hidden=\"true\">#</a> 第一个 Java 程序</h2>\n<!--beforebegin--><div class=\"language-java extra-class\"><!--afterbegin--><pre v-pre class=\"language-java\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><div class=\"warning custom-block\"><p class=\"custom-block-title\">注意</p>\n<ul>\n<li>Java 程序必须写到 <code>.java</code> 文件中</li>\n<li><code>.class</code> 文件名对应类名。每一个类在编译后会生成一个对应的 <code>.class</code> 文件</li>\n<li>当一个类用 <code>public</code> 修饰时，这个类被称为<strong>公共类</strong>。公共类要求和 Java 文件名完全一致</li>\n</ul>\n</div>\n<h2 id=\"命令行下的操作\"><a class=\"header-anchor\" href=\"#命令行下的操作\" aria-hidden=\"true\">#</a> 命令行下的操作</h2>\n<p>编译当前 Java 文件使用命令<code>javac</code>，完整命令：<br>\n<strong>Input</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>javac -d 编译完成后存放路径 要编译的.java文件\n</code></pre>\n<!--beforeend--></div><!--afterend--><br>\n<p>存在类依赖时使用<code>java -cp</code>来命令指定依赖路径，完整命令：<br>\n<strong>Input</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>java -cp .class文件的存放路径 .class文件的文件名\n</code></pre>\n<!--beforeend--></div><!--afterend--><br>\n<p>生成 JavaDoc使用命令<code>javadoc -d</code>，完整命令：<br>\n<strong>Input</strong></p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>javadoc -d 文档生成路径 编译的.java文件\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"内存管理概论\"><a class=\"header-anchor\" href=\"#内存管理概论\" aria-hidden=\"true\">#</a> 内存管理概论</h2>\n<h3 id=\"内存分区\"><a class=\"header-anchor\" href=\"#内存分区\" aria-hidden=\"true\">#</a> 内存分区</h3>\n<p><img src=\"/img/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.jpg\" alt=\"内存分区\"></p>\n<ul>\n<li>\n<p>寄存器<br>\n负责程序计数和任务调度</p>\n</li>\n<li>\n<p>本地方法栈<br>\n存储本地方法</p>\n</li>\n<li>\n<p>栈内存<br>\n执行代码块，存储局部变量</p>\n</li>\n<li>\n<p>堆内存<br>\n存储对象（对象生命周期结束后被<code>GC</code>回收）</p>\n</li>\n<li>\n<p>方法区<br>\n存储类的信息，一旦存入不再移除<br>\n方法区溢出会报<code>OutOfMemoryError</code>错误<br>\n其中：</p>\n<ul>\n<li>\n<p>静态区<br>\n存储静态属性和静态方法<br>\n静态属性存储在此区后自动赋默认值</p>\n</li>\n<li>\n<p>静态常量池<br>\n存储类成员属性和成员方法信息</p>\n</li>\n<li>\n<p>运行时常量池<br>\n存储计算机常量和被<code>final</code>修饰的常量副本</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"垃圾分代回收机制\"><a class=\"header-anchor\" href=\"#垃圾分代回收机制\" aria-hidden=\"true\">#</a> 垃圾分代回收机制</h3>\n<p>对象在堆内存中存储。当对象在使用完成后，会在某个不定的时刻被垃圾回收器<code>GC</code>解析。<br>\n值得注意的是：<strong>垃圾回收过程无法手动控制</strong>。</p>\n<ul>\n<li>\n<p>堆内存分为<strong>新生代区</strong>和<strong>老年代区</strong>。</p>\n</li>\n<li>\n<p>新生代区分为<strong>伊甸园区</strong>和<strong>幸存区</strong>。</p>\n</li>\n<li>\n<p>一个新创建的对象会被生成在伊甸园区，若在伊甸园区的对象经过一次回收过程仍然存活，则被移动到幸存区。</p>\n</li>\n<li>\n<p>幸存区的回收扫描频率略低于伊甸园区。在幸存区经过多次扫描，若对象仍然存活，则被移动到老年代区。</p>\n</li>\n<li>\n<p>老年代区的回收扫描频率会远远低于新生代区。</p>\n</li>\n<li>\n<p>当老年代区中的对象被回收时，会导致程序卡顿甚至崩溃。</p>\n</li>\n<li>\n<p>发生在新生代区的垃圾回收称为<strong>初代回收 (Minor GC)</strong>.</p>\n</li>\n<li>\n<p>发生在老年代区的垃圾回收称为<strong>完全回收 (Full GC)</strong>.</p>\n</li>\n</ul>\n</div>\n",null]}